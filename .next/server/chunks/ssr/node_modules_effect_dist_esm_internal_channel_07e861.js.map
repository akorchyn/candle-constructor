{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"channel.js","sources":["file:///home/yurtur/projects/candle-constructor/node_modules/effect/src/internal/channel.ts"],"sourcesContent":["import * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport * as Deferred from \"../Deferred.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport * as Fiber from \"../Fiber.js\"\nimport * as FiberRef from \"../FiberRef.js\"\nimport { constVoid, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as Layer from \"../Layer.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport type * as MergeState from \"../MergeState.js\"\nimport type * as MergeStrategy from \"../MergeStrategy.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty, type Predicate } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as SingleProducerAsyncInput from \"../SingleProducerAsyncInput.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport * as executor from \"./channel/channelExecutor.js\"\nimport type * as ChannelState from \"./channel/channelState.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as mergeState from \"./channel/mergeState.js\"\nimport * as _mergeStrategy from \"./channel/mergeStrategy.js\"\nimport * as singleProducerAsyncInput from \"./channel/singleProducerAsyncInput.js\"\nimport * as coreEffect from \"./core-effect.js\"\nimport * as core from \"./core-stream.js\"\nimport * as MergeDecisionOpCodes from \"./opCodes/channelMergeDecision.js\"\nimport * as MergeStateOpCodes from \"./opCodes/channelMergeState.js\"\nimport * as ChannelStateOpCodes from \"./opCodes/channelState.js\"\nimport * as tracer from \"./tracer.js\"\n\n/** @internal */\nexport const acquireUseRelease = <Acquired, OutErr, Env, OutElem1, InElem, InErr, OutDone, InDone>(\n  acquire: Effect.Effect<Acquired, OutErr, Env>,\n  use: (a: Acquired) => Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  release: (a: Acquired, exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n): Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env> =>\n  core.flatMap(\n    core.fromEffect(\n      Ref.make<\n        (exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n      >(() => Effect.void)\n    ),\n    (ref) =>\n      pipe(\n        core.fromEffect(\n          Effect.uninterruptible(\n            Effect.tap(\n              acquire,\n              (a) => Ref.set(ref, (exit) => release(a, exit))\n            )\n          )\n        ),\n        core.flatMap(use),\n        core.ensuringWith((exit) => Effect.flatMap(Ref.get(ref), (f) => f(exit)))\n      )\n  )\n\n/** @internal */\nexport const as = dual<\n  <OutDone2>(\n    value: OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    value: OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  value: OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> => map(self, () => value))\n\n/** @internal */\nexport const asVoid = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, void, InDone, Env> => map(self, constVoid)\n\n/** @internal */\nexport const buffer = <InElem, InErr, InDone>(\n  options: {\n    readonly empty: InElem\n    readonly isEmpty: Predicate<InElem>\n    readonly ref: Ref.Ref<InElem>\n  }\n): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n  core.suspend(() => {\n    const doBuffer = <InErr, InElem, InDone>(\n      empty: InElem,\n      isEmpty: Predicate<InElem>,\n      ref: Ref.Ref<InElem>\n    ): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n      unwrap(\n        Ref.modify(ref, (inElem) =>\n          isEmpty(inElem) ?\n            [\n              core.readWith({\n                onInput: (input: InElem) =>\n                  core.flatMap(\n                    core.write(input),\n                    () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n                  ),\n                onFailure: (error: InErr) => core.fail(error),\n                onDone: (done: InDone) => core.succeedNow(done)\n              }),\n              inElem\n            ] as const :\n            [\n              core.flatMap(\n                core.write(inElem),\n                () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n              ),\n              empty\n            ] as const)\n      )\n    return doBuffer(options.empty, options.isEmpty, options.ref)\n  })\n\n/** @internal */\nexport const bufferChunk = <InElem, InErr, InDone>(\n  ref: Ref.Ref<Chunk.Chunk<InElem>>\n): Channel.Channel<Chunk.Chunk<InElem>, Chunk.Chunk<InElem>, InErr, InErr, InDone, InDone> =>\n  buffer({\n    empty: Chunk.empty(),\n    isEmpty: Chunk.isEmpty,\n    ref\n  })\n\n/** @internal */\nexport const catchAll = dual<\n  <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    core.catchAllCause(self, (cause) =>\n      Either.match(Cause.failureOrCause(cause), {\n        onLeft: f,\n        onRight: core.failCause\n      }))\n)\n\n/** @internal */\nexport const concatMap = dual<\n  <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => <Env, InErr, InElem, InDone, OutErr, OutDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >,\n  <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >\n>(2, <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n): Channel.Channel<\n  OutElem2,\n  InElem & InElem2,\n  OutErr | OutErr2,\n  InErr & InErr2,\n  unknown,\n  InDone & InDone2,\n  Env | Env2\n> => core.concatMapWith(self, f, () => void 0, () => void 0))\n\n/** @internal */\nexport const collect = dual<\n  <OutElem, OutElem2>(\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  pf: (o: OutElem) => Option.Option<OutElem2>\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const collector: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (out) =>\n        Option.match(pf(out), {\n          onNone: () => collector,\n          onSome: (out2) => core.flatMap(core.write(out2), () => collector)\n        }),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, collector)\n})\n\n/** @internal */\nexport const concatOut = <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >\n): Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env> => core.concatAll(self)\n\n/** @internal */\nexport const mapInput = dual<\n  <InDone0, InDone>(\n    f: (a: InDone0) => InDone\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InDone0) => InDone\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InDone0) => InDone\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done: InDone0) => core.succeedNow(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <InDone0, InDone, InErr, Env1>(\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done) => core.fromEffect(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputError = dual<\n  <InErr0, InErr>(\n    f: (a: InErr0) => InErr\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InErr0) => InErr\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InErr0) => InErr\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fail(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputErrorEffect = dual<\n  <InErr0, InDone, InErr, Env1>(\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fromEffect(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputIn = dual<\n  <InElem0, InElem>(\n    f: (a: InElem0) => InElem\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => InElem\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => InElem\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(f(inElem)), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputInEffect = dual<\n  <InElem0, InElem, InErr, Env1>(\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => <OutElem, OutErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.flatMap(core.fromEffect(f(inElem)), core.write), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const doneCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env> =>\n  core.suspend(() => {\n    const builder: Array<OutElem> = []\n    return pipe(\n      core.pipeTo(self, doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)),\n      core.flatMap((outDone) => core.succeed([Chunk.unsafeFromArray(builder), outDone]))\n    )\n  })\n\n/** @internal */\nconst doneCollectReader = <Env, OutErr, OutElem, OutDone>(\n  builder: Array<OutElem>\n): Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> => {\n  return core.readWith({\n    onInput: (outElem) =>\n      core.flatMap(\n        core.sync(() => {\n          builder.push(outElem)\n        }),\n        () => doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)\n      ),\n    onFailure: core.fail,\n    onDone: core.succeed\n  })\n}\n\n/** @internal */\nexport const drain = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const drainer: Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWithCause({\n      onInput: () => drainer,\n      onFailure: core.failCause,\n      onDone: core.succeed\n    })\n  return core.pipeTo(self, drainer)\n}\n\n/** @internal */\nexport const emitCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env> =>\n  core.flatMap(doneCollect(self), core.write)\n\n/** @internal */\nexport const ensuring = dual<\n  <Z, Env1>(\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, Z>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  finalizer: Effect.Effect<Z, never, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> =>\n  core.ensuringWith(self, () => finalizer))\n\n/** @internal */\nexport const context = <Env>(): Channel.Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env> =>\n  core.fromEffect(Effect.context<Env>())\n\n/** @internal */\nexport const contextWith = <Env, OutDone>(\n  f: (env: Context.Context<Env>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, Env> => map(context<Env>(), f)\n\n/** @internal */\nexport const contextWithChannel = <\n  Env,\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env1\n>(\n  f: (env: Context.Context<Env>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> => core.flatMap(context<Env>(), f)\n\n/** @internal */\nexport const contextWithEffect = <Env, OutDone, OutErr, Env1>(\n  f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1> => mapEffect(context<Env>(), f)\n\n/** @internal */\nexport const flatten = <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone2,\n  InDone1,\n  Env1,\n  InDone,\n  Env\n>(\n  self: Channel.Channel<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone2,\n  InDone & InDone1,\n  Env | Env1\n> => core.flatMap(self, identity)\n\n/** @internal */\nexport const foldChannel = dual<\n  <\n    OutErr,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutDone,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutElem2,\n  InElem2,\n  OutErr2,\n  InErr2,\n  OutDone2,\n  InDone2,\n  Env2\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly onFailure: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSuccess: (done: OutDone) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n  }\n): Channel.Channel<\n  OutElem | OutElem2 | OutElem1,\n  InElem & InElem1 & InElem2,\n  OutErr2 | OutErr1,\n  InErr & InErr1 & InErr2,\n  OutDone2 | OutDone1,\n  InDone & InDone1 & InDone2,\n  Env | Env1 | Env2\n> =>\n  core.foldCauseChannel(self, {\n    onFailure: (cause) => {\n      const either = Cause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return options.onFailure(either.left)\n        }\n        case \"Right\": {\n          return core.failCause(either.right)\n        }\n      }\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/** @internal */\nexport const fromEither = <R, L>(\n  either: Either.Either<R, L>\n): Channel.Channel<never, unknown, L, unknown, R, unknown> =>\n  core.suspend(() => Either.match(either, { onLeft: core.fail, onRight: core.succeed }))\n\n/** @internal */\nexport const fromInput = <Err, Elem, Done>(\n  input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrap(\n    input.takeWith(\n      core.failCause,\n      (elem) => core.flatMap(core.write(elem), () => fromInput(input)),\n      core.succeed\n    )\n  )\n\n/** @internal */\nexport const fromPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrapScoped(Effect.map(PubSub.subscribe(pubsub), fromQueue))\n\n/** @internal */\nexport const fromPubSubScoped = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Effect.Effect<Channel.Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope> =>\n  Effect.map(PubSub.subscribe(pubsub), fromQueue)\n\n/** @internal */\nexport const fromOption = <A>(\n  option: Option.Option<A>\n): Channel.Channel<never, unknown, Option.Option<never>, unknown, A, unknown> =>\n  core.suspend(() =>\n    Option.match(option, {\n      onNone: () => core.fail(Option.none()),\n      onSome: core.succeed\n    })\n  )\n\n/** @internal */\nexport const fromQueue = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> => core.suspend(() => fromQueueInternal(queue))\n\n/** @internal */\nconst fromQueueInternal = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  pipe(\n    core.fromEffect(Queue.take(queue)),\n    core.flatMap(Either.match({\n      onLeft: Exit.match({\n        onFailure: core.failCause,\n        onSuccess: core.succeedNow\n      }),\n      onRight: (elem) =>\n        core.flatMap(\n          core.write(elem),\n          () => fromQueueInternal(queue)\n        )\n    }))\n  )\n\n/** @internal */\nexport const identityChannel = <Elem, Err, Done>(): Channel.Channel<Elem, Elem, Err, Err, Done, Done> =>\n  core.readWith({\n    onInput: (input: Elem) => core.flatMap(core.write(input), () => identityChannel()),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const interruptWhen = dual<\n  <OutDone1, OutErr1, Env1>(\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  effect: Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env1 | Env> =>\n  mergeWith(self, {\n    other: core.fromEffect(effect),\n    onSelfDone: (selfDone) => mergeDecision.Done(Effect.suspend(() => selfDone)),\n    onOtherDone: (effectDone) => mergeDecision.Done(Effect.suspend(() => effectDone))\n  }))\n\n/** @internal */\nexport const interruptWhenDeferred = dual<\n  <OutDone1, OutErr1>(\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutErr1, OutDone1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  deferred: Deferred.Deferred<OutDone1, OutErr1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env> =>\n  interruptWhen(self, Deferred.await(deferred)))\n\n/** @internal */\nexport const map = dual<\n  <OutDone, OutDone2>(\n    f: (out: OutDone) => OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (out: OutDone) => OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (out: OutDone) => OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> =>\n  core.flatMap(self, (a) => core.sync(() => f(a))))\n\n/** @internal */\nexport const mapEffect = dual<\n  <OutDone, OutDone1, OutErr1, Env1>(\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1> =>\n  core.flatMap(self, (z) => core.fromEffect(f(z))))\n\n/** @internal */\nexport const mapError = dual<\n  <OutErr, OutErr2>(\n    f: (err: OutErr) => OutErr2\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (err: OutErr) => OutErr2\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (err: OutErr) => OutErr2\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> => mapErrorCause(self, Cause.map(f)))\n\n/** @internal */\nexport const mapErrorCause = dual<\n  <OutErr, OutErr2>(\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> =>\n  core.catchAllCause(self, (cause) => core.failCause(f(cause))))\n\n/** @internal */\nexport const mapOut = dual<\n  <OutElem, OutElem2>(\n    f: (o: OutElem) => OutElem2\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => OutElem2\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => OutElem2\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (outElem) => core.flatMap(core.write(f(outElem)), () => reader),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffect = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<OutElem1, OutElem, OutErr | OutErr1, OutErr, OutDone, OutDone, Env | Env1> = core\n    .readWithCause({\n      onInput: (outElem) =>\n        pipe(\n          core.fromEffect(f(outElem)),\n          core.flatMap(core.write),\n          core.flatMap(() => reader)\n        ),\n      onFailure: core.failCause,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffectPar = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n  n: number\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> =>\n  unwrapScopedWith(\n    (scope) =>\n      Effect.gen(function*() {\n        const input = yield* singleProducerAsyncInput.make<InErr, InElem, InDone>()\n        const queueReader = fromInput(input)\n        const queue = yield* Queue.bounded<Effect.Effect<Either.Either<OutElem1, OutDone>, OutErr | OutErr1, Env1>>(n)\n        yield* Scope.addFinalizer(scope, Queue.shutdown(queue))\n        const errorSignal = yield* Deferred.make<never, OutErr1>()\n        const withPermits = n === Number.POSITIVE_INFINITY ?\n          ((_: number) => identity) :\n          (yield* Effect.makeSemaphore(n)).withPermits\n        const pull = yield* queueReader.pipe(core.pipeTo(self), toPullIn(scope))\n        yield* pull.pipe(\n          Effect.matchCauseEffect({\n            onFailure: (cause) => Queue.offer(queue, Effect.failCause(cause)),\n            onSuccess: Either.match({\n              onLeft: (outDone) =>\n                Effect.zipRight(\n                  Effect.interruptible(withPermits(n)(Effect.void)),\n                  Effect.asVoid(Queue.offer(queue, Effect.succeed(Either.left(outDone))))\n                ),\n              onRight: (outElem) =>\n                Effect.gen(function*() {\n                  const deferred = yield* Deferred.make<OutElem1, OutErr1>()\n                  const latch = yield* Deferred.make<void>()\n                  yield* Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right))\n                  yield* Deferred.succeed(latch, void 0).pipe(\n                    Effect.zipRight(\n                      Effect.uninterruptibleMask((restore) =>\n                        Effect.exit(restore(Deferred.await(errorSignal))).pipe(\n                          Effect.raceFirst(Effect.exit(restore(f(outElem)))),\n                          Effect.flatMap(identity)\n                        )\n                      ).pipe(\n                        Effect.tapErrorCause((cause) => Deferred.failCause(errorSignal, cause)),\n                        Effect.intoDeferred(deferred)\n                      )\n                    ),\n                    withPermits(1),\n                    Effect.forkIn(scope)\n                  )\n                  yield* Deferred.await(latch)\n                })\n            })\n          }),\n          Effect.forever,\n          Effect.interruptible,\n          Effect.forkIn(scope)\n        )\n        const consumer: Channel.Channel<OutElem1, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env1> = unwrap(\n          Effect.matchCause(Effect.flatten(Queue.take(queue)), {\n            onFailure: core.failCause,\n            onSuccess: Either.match({\n              onLeft: core.succeedNow,\n              onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n            })\n          })\n        )\n        return core.embedInput(consumer, input)\n      })\n  ))\n\n/** @internal */\nexport const mergeAll = (\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) => {\n  return <\n    OutElem,\n    InElem1,\n    OutErr1,\n    InErr1,\n    InDone1,\n    Env1,\n    InElem,\n    OutErr,\n    InErr,\n    InDone,\n    Env\n  >(\n    channels: Channel.Channel<\n      Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      unknown,\n      InDone,\n      Env\n    >\n  ): Channel.Channel<\n    OutElem,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  > => mergeAllWith(options)(channels, constVoid)\n}\n\n/** @internal */\nexport const mergeAllUnbounded = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    unknown,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, constVoid)\n\n/** @internal */\nexport const mergeAllUnboundedWith = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, f)\n\n/** @internal */\nexport const mergeAllWith = (\n  {\n    bufferSize = 16,\n    concurrency,\n    mergeStrategy = _mergeStrategy.BackPressure()\n  }: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) =>\n<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> =>\n  unwrapScopedWith(\n    (scope) =>\n      Effect.gen(function*() {\n        const concurrencyN = concurrency === \"unbounded\" ? Number.MAX_SAFE_INTEGER : concurrency\n        const input = yield* singleProducerAsyncInput.make<\n          InErr & InErr1,\n          InElem & InElem1,\n          InDone & InDone1\n        >()\n        const queueReader = fromInput(input)\n        const queue = yield* Queue.bounded<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr | OutErr1, Env>>(\n          bufferSize\n        )\n        yield* Scope.addFinalizer(scope, Queue.shutdown(queue))\n        const cancelers = yield* Queue.unbounded<Deferred.Deferred<void>>()\n        yield* Scope.addFinalizer(scope, Queue.shutdown(cancelers))\n        const lastDone = yield* Ref.make<Option.Option<OutDone>>(Option.none())\n        const errorSignal = yield* Deferred.make<void>()\n        const withPermits = (yield* Effect.makeSemaphore(concurrencyN)).withPermits\n        const pull = yield* toPullIn(core.pipeTo(queueReader, channels), scope)\n\n        function evaluatePull(\n          pull: Effect.Effect<\n            Either.Either<OutElem, OutDone>,\n            OutErr | OutErr1,\n            Env | Env1\n          >\n        ) {\n          return pull.pipe(\n            Effect.flatMap(Either.match({\n              onLeft: (done) => Effect.succeed(Option.some(done)),\n              onRight: (outElem) =>\n                Effect.as(\n                  Queue.offer(queue, Effect.succeed(Either.right(outElem))),\n                  Option.none()\n                )\n            })),\n            Effect.repeat({ until: (_): _ is Option.Some<OutDone> => Option.isSome(_) }),\n            Effect.flatMap((outDone) =>\n              Ref.update(\n                lastDone,\n                Option.match({\n                  onNone: () => Option.some(outDone.value),\n                  onSome: (lastDone) => Option.some(f(lastDone, outDone.value))\n                })\n              )\n            ),\n            Effect.catchAllCause((cause) =>\n              Cause.isInterrupted(cause)\n                ? Effect.failCause(cause)\n                : Queue.offer(queue, Effect.failCause(cause)).pipe(\n                  Effect.zipRight(Deferred.succeed(errorSignal, void 0)),\n                  Effect.asVoid\n                )\n            )\n          )\n        }\n\n        yield* pull.pipe(\n          Effect.matchCauseEffect({\n            onFailure: (cause) =>\n              Queue.offer(queue, Effect.failCause(cause)).pipe(\n                Effect.zipRight(Effect.succeed(false))\n              ),\n            onSuccess: Either.match({\n              onLeft: (outDone) =>\n                Effect.raceWith(\n                  Effect.interruptible(Deferred.await(errorSignal)),\n                  Effect.interruptible(withPermits(concurrencyN)(Effect.void)),\n                  {\n                    onSelfDone: (_, permitAcquisition) => Effect.as(Fiber.interrupt(permitAcquisition), false),\n                    onOtherDone: (_, failureAwait) =>\n                      Effect.zipRight(\n                        Fiber.interrupt(failureAwait),\n                        Ref.get(lastDone).pipe(\n                          Effect.flatMap(Option.match({\n                            onNone: () => Queue.offer(queue, Effect.succeed(Either.left(outDone))),\n                            onSome: (lastDone) => Queue.offer(queue, Effect.succeed(Either.left(f(lastDone, outDone))))\n                          })),\n                          Effect.as(false)\n                        )\n                      )\n                  }\n                ),\n              onRight: (channel) =>\n                _mergeStrategy.match(mergeStrategy, {\n                  onBackPressure: () =>\n                    Effect.gen(function*() {\n                      const latch = yield* Deferred.make<void>()\n                      const raceEffects = Effect.scopedWith((scope) =>\n                        toPullIn(core.pipeTo(queueReader, channel), scope).pipe(\n                          Effect.flatMap((pull) =>\n                            Effect.race(\n                              Effect.exit(evaluatePull(pull)),\n                              Effect.exit(Effect.interruptible(Deferred.await(errorSignal)))\n                            )\n                          ),\n                          Effect.flatMap(identity)\n                        )\n                      )\n                      yield* Deferred.succeed(latch, void 0).pipe(\n                        Effect.zipRight(raceEffects),\n                        withPermits(1),\n                        Effect.forkIn(scope)\n                      )\n                      yield* Deferred.await(latch)\n                      const errored = yield* Deferred.isDone(errorSignal)\n                      return !errored\n                    }),\n                  onBufferSliding: () =>\n                    Effect.gen(function*() {\n                      const canceler = yield* Deferred.make<void>()\n                      const latch = yield* Deferred.make<void>()\n                      const size = yield* Queue.size(cancelers)\n                      yield* Queue.take(cancelers).pipe(\n                        Effect.flatMap((canceler) => Deferred.succeed(canceler, void 0)),\n                        Effect.when(() => size >= concurrencyN)\n                      )\n                      yield* Queue.offer(cancelers, canceler)\n                      const raceEffects = Effect.scopedWith((scope) =>\n                        toPullIn(core.pipeTo(queueReader, channel), scope).pipe(\n                          Effect.flatMap((pull) =>\n                            Effect.exit(evaluatePull(pull)).pipe(\n                              Effect.race(Effect.exit(Effect.interruptible(Deferred.await(errorSignal)))),\n                              Effect.race(Effect.exit(Effect.interruptible(Deferred.await(canceler))))\n                            )\n                          ),\n                          Effect.flatMap(identity)\n                        )\n                      )\n                      yield* Deferred.succeed(latch, void 0).pipe(\n                        Effect.zipRight(raceEffects),\n                        withPermits(1),\n                        Effect.forkIn(scope)\n                      )\n                      yield* Deferred.await(latch)\n                      const errored = yield* Deferred.isDone(errorSignal)\n                      return !errored\n                    })\n                })\n            })\n          }),\n          Effect.repeat({ while: (_) => _ }),\n          Effect.forkIn(scope)\n        )\n\n        const consumer: Channel.Channel<OutElem, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env | Env1> =\n          pipe(\n            Queue.take(queue),\n            Effect.flatten,\n            Effect.matchCause({\n              onFailure: core.failCause,\n              onSuccess: Either.match({\n                onLeft: core.succeedNow,\n                onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n              })\n            }),\n            unwrap\n          )\n\n        return core.embedInput(consumer, input)\n      })\n  )\n\n/** @internal */\nexport const mergeMap = dual<\n  <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll(options)(mapOut(self, f)))\n\n/** @internal */\nexport const mergeOut = dual<\n  (\n    n: number\n  ) => <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >,\n    n: number\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(2, <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  n: number\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll({ concurrency: n })(mapOut(self, identity)))\n\n/** @internal */\nexport const mergeOutWith = dual<\n  <OutDone1>(\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >,\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(3, <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone1,\n    InDone,\n    Env\n  >,\n  n: number,\n  f: (o1: OutDone1, o2: OutDone1) => OutDone1\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone1,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: n })(mapOut(self, identity), f))\n\n/** @internal */\nexport const mergeWith = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutErr2,\n    OutDone2,\n    OutErr3,\n    OutDone3\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutErr2,\n  OutDone2,\n  OutErr3,\n  OutDone3\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSelfDone: (\n      exit: Exit.Exit<OutDone, OutErr>\n    ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n    readonly onOtherDone: (\n      ex: Exit.Exit<OutDone1, OutErr1>\n    ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n  }\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr2 | OutErr3,\n  InErr & InErr1,\n  OutDone2 | OutDone3,\n  InDone & InDone1,\n  Env1 | Env\n> => {\n  function merge(scope: Scope.Scope) {\n    return Effect.gen(function*() {\n      type State = MergeState.MergeState<\n        Env | Env1,\n        OutErr,\n        OutErr1,\n        OutErr2 | OutErr3,\n        OutElem | OutElem1,\n        OutDone,\n        OutDone1,\n        OutDone2 | OutDone3\n      >\n\n      const input = yield* singleProducerAsyncInput.make<\n        InErr & InErr1,\n        InElem & InElem1,\n        InDone & InDone1\n      >()\n      const queueReader = fromInput(input)\n      const pullL = yield* toPullIn(core.pipeTo(queueReader, self), scope)\n      const pullR = yield* toPullIn(core.pipeTo(queueReader, options.other), scope)\n\n      function handleSide<Err, Done, Err2, Done2>(\n        exit: Exit.Exit<Either.Either<OutElem | OutElem1, Done>, Err>,\n        fiber: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>,\n        pull: Effect.Effect<Either.Either<OutElem | OutElem1, Done>, Err, Env | Env1>\n      ) {\n        return (\n          done: (\n            ex: Exit.Exit<Done, Err>\n          ) => MergeDecision.MergeDecision<\n            Env | Env1,\n            Err2,\n            Done2,\n            OutErr2 | OutErr3,\n            OutDone2 | OutDone3\n          >,\n          both: (\n            f1: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done>, Err>,\n            f2: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>\n          ) => State,\n          single: (\n            f: (\n              ex: Exit.Exit<Done2, Err2>\n            ) => Effect.Effect<OutDone2 | OutDone3, OutErr2 | OutErr3, Env | Env1>\n          ) => State\n        ): Effect.Effect<\n          Channel.Channel<\n            OutElem | OutElem1,\n            unknown,\n            OutErr2 | OutErr3,\n            unknown,\n            OutDone2 | OutDone3,\n            unknown,\n            Env | Env1\n          >,\n          never,\n          Env | Env1\n        > => {\n          function onDecision(\n            decision: MergeDecision.MergeDecision<\n              Env | Env1,\n              Err2,\n              Done2,\n              OutErr2 | OutErr3,\n              OutDone2 | OutDone3\n            >\n          ): Effect.Effect<\n            Channel.Channel<\n              OutElem | OutElem1,\n              unknown,\n              OutErr2 | OutErr3,\n              unknown,\n              OutDone2 | OutDone3,\n              unknown,\n              Env | Env1\n            >\n          > {\n            const op = decision as mergeDecision.Primitive\n            if (op._tag === MergeDecisionOpCodes.OP_DONE) {\n              return Effect.succeed(\n                core.fromEffect(\n                  Effect.zipRight(\n                    Fiber.interrupt(fiber),\n                    op.effect\n                  )\n                )\n              )\n            }\n            return Effect.map(\n              Fiber.await(fiber),\n              Exit.match({\n                onFailure: (cause) => core.fromEffect(op.f(Exit.failCause(cause))),\n                onSuccess: Either.match({\n                  onLeft: (done) => core.fromEffect(op.f(Exit.succeed(done))),\n                  onRight: (elem) => zipRight(core.write(elem), go(single(op.f)))\n                })\n              })\n            )\n          }\n\n          return Exit.match(exit, {\n            onFailure: (cause) => onDecision(done(Exit.failCause(cause))),\n            onSuccess: Either.match({\n              onLeft: (z) => onDecision(done(Exit.succeed(z))),\n              onRight: (elem) =>\n                Effect.succeed(\n                  core.flatMap(core.write(elem), () =>\n                    core.flatMap(\n                      core.fromEffect(Effect.forkIn(Effect.interruptible(pull), scope)),\n                      (leftFiber) => go(both(leftFiber, fiber))\n                    ))\n                )\n            })\n          })\n        }\n      }\n\n      function go(\n        state: State\n      ): Channel.Channel<\n        OutElem | OutElem1,\n        unknown,\n        OutErr2 | OutErr3,\n        unknown,\n        OutDone2 | OutDone3,\n        unknown,\n        Env | Env1\n      > {\n        switch (state._tag) {\n          case MergeStateOpCodes.OP_BOTH_RUNNING: {\n            const leftJoin = Effect.interruptible(Fiber.join(state.left))\n            const rightJoin = Effect.interruptible(Fiber.join(state.right))\n            return unwrap(\n              Effect.raceWith(leftJoin, rightJoin, {\n                onSelfDone: (leftExit, rf) =>\n                  Effect.zipRight(\n                    Fiber.interrupt(rf),\n                    handleSide(leftExit, state.right, pullL)(\n                      options.onSelfDone,\n                      mergeState.BothRunning,\n                      (f) => mergeState.LeftDone(f)\n                    )\n                  ),\n                onOtherDone: (rightExit, lf) =>\n                  Effect.zipRight(\n                    Fiber.interrupt(lf),\n                    handleSide(rightExit, state.left, pullR)(\n                      options.onOtherDone as (\n                        ex: Exit.Exit<OutDone1, InErr1 | OutErr1>\n                      ) => MergeDecision.MergeDecision<\n                        Env1 | Env,\n                        OutErr,\n                        OutDone,\n                        OutErr2 | OutErr3,\n                        OutDone2 | OutDone3\n                      >,\n                      (left, right) => mergeState.BothRunning(right, left),\n                      (f) => mergeState.RightDone(f)\n                    )\n                  )\n              })\n            )\n          }\n          case MergeStateOpCodes.OP_LEFT_DONE: {\n            return unwrap(\n              Effect.map(\n                Effect.exit(pullR),\n                Exit.match({\n                  onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                  onSuccess: Either.match({\n                    onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                    onRight: (elem) =>\n                      core.flatMap(\n                        core.write(elem),\n                        () => go(mergeState.LeftDone(state.f))\n                      )\n                  })\n                })\n              )\n            )\n          }\n          case MergeStateOpCodes.OP_RIGHT_DONE: {\n            return unwrap(\n              Effect.map(\n                Effect.exit(pullL),\n                Exit.match({\n                  onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                  onSuccess: Either.match({\n                    onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                    onRight: (elem) =>\n                      core.flatMap(\n                        core.write(elem),\n                        () => go(mergeState.RightDone(state.f))\n                      )\n                  })\n                })\n              )\n            )\n          }\n        }\n      }\n\n      return core.fromEffect(\n        Effect.withFiberRuntime<\n          MergeState.MergeState<\n            Env | Env1,\n            OutErr,\n            OutErr1,\n            OutErr2 | OutErr3,\n            OutElem | OutElem1,\n            OutDone,\n            OutDone1,\n            OutDone2 | OutDone3\n          >,\n          never,\n          Env | Env1\n        >((parent) => {\n          const inherit = Effect.withFiberRuntime<void, never, never>((state) => {\n            ;(state as any).transferChildren((parent as any).scope())\n            return Effect.void\n          })\n          const leftFiber = Effect.interruptible(pullL).pipe(\n            Effect.ensuring(inherit),\n            Effect.forkIn(scope)\n          )\n          const rightFiber = Effect.interruptible(pullR).pipe(\n            Effect.ensuring(inherit),\n            Effect.forkIn(scope)\n          )\n          return Effect.zipWith(\n            leftFiber,\n            rightFiber,\n            (left, right): State =>\n              mergeState.BothRunning<\n                Env | Env1,\n                OutErr,\n                OutErr1,\n                OutErr2 | OutErr3,\n                OutElem | OutElem1,\n                OutDone,\n                OutDone1,\n                OutDone2 | OutDone3\n              >(left, right)\n          )\n        })\n      ).pipe(\n        core.flatMap(go),\n        core.embedInput(input)\n      )\n    })\n  }\n  return unwrapScopedWith(merge)\n})\n\n/** @internal */\nexport const never: Channel.Channel<never, unknown, never, unknown, never, unknown> = core.fromEffect(\n  Effect.never\n)\n\n/** @internal */\nexport const orDie = dual<\n  <E>(\n    error: LazyArg<E>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    error: LazyArg<E>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  error: LazyArg<E>\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> => orDieWith(self, error))\n\n/** @internal */\nexport const orDieWith = dual<\n  <OutErr>(\n    f: (e: OutErr) => unknown\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (e: OutErr) => unknown\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (e: OutErr) => unknown\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> =>\n  catchAll(self, (e) => {\n    throw f(e)\n  }) as Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>)\n\n/** @internal */\nexport const orElse = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > => catchAll(self, that)\n)\n\n/** @internal */\nexport const pipeToOrFail = dual<\n  <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => <InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n): Channel.Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2> =>\n  core.suspend(() => {\n    let channelException: Channel.ChannelException<OutErr | OutErr2> | undefined = undefined\n\n    const reader: Channel.Channel<OutElem, OutElem, never, OutErr, OutDone, OutDone, Env> = core\n      .readWith({\n        onInput: (outElem) => core.flatMap(core.write(outElem), () => reader),\n        onFailure: (outErr) => {\n          channelException = ChannelException(outErr)\n          return core.failCause(Cause.die(channelException))\n        },\n        onDone: core.succeedNow\n      })\n\n    const writer: Channel.Channel<\n      OutElem2,\n      OutElem2,\n      OutErr2,\n      OutErr2,\n      OutDone2,\n      OutDone2,\n      Env2\n    > = core.readWithCause({\n      onInput: (outElem) => pipe(core.write(outElem), core.flatMap(() => writer)),\n      onFailure: (cause) =>\n        Cause.isDieType(cause) &&\n          isChannelException(cause.defect) &&\n          Equal.equals(cause.defect, channelException)\n          ? core.fail(cause.defect.error as OutErr2)\n          : core.failCause(cause),\n      onDone: core.succeedNow\n    })\n\n    return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer)\n  }))\n\n/** @internal */\nexport const provideService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, T extends Context.Tag<any, any>>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, T extends Context.Tag<any, any>>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  tag: T,\n  service: Context.Tag.Service<T>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>> => {\n  return core.flatMap(\n    context<any>(),\n    (context) => core.provideContext(self, Context.add(context, tag, service))\n  )\n})\n\n/** @internal */\nexport const provideLayer = dual<\n  <Env, OutErr2, Env0>(\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  layer: Layer.Layer<Env, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0> =>\n  unwrapScopedWith((scope) =>\n    Effect.map(Layer.buildWithScope(layer, scope), (context) => core.provideContext(self, context))\n  ))\n\n/** @internal */\nexport const mapInputContext = dual<\n  <Env0, Env>(\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (env: Context.Context<Env0>) => Context.Context<Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0> =>\n  contextWithChannel((context: Context.Context<Env0>) => core.provideContext(self, f(context))))\n\n/** @internal */\nexport const provideSomeLayer = dual<\n  <R2, OutErr2, Env0>(\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n  layer: Layer.Layer<R2, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>> =>\n  // @ts-expect-error\n  provideLayer(self, Layer.merge(Layer.context<Exclude<R, R2>>(), layer)))\n\n/** @internal */\nexport const read = <In>(): Channel.Channel<never, In, Option.Option<never>, unknown, In, unknown> =>\n  core.readOrFail<Option.Option<never>, In>(Option.none())\n\n/** @internal */\nexport const repeated = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env> => core.flatMap(self, () => repeated(self))\n\n/** @internal */\nexport const run = <OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env> => Effect.scopedWith((scope) => executor.runIn(self, scope))\n\n/** @internal */\nexport const runCollect = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env> => run(core.collectElements(self))\n\n/** @internal */\nexport const runDrain = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env> => run(drain(self))\n\n/** @internal */\nexport const runScoped = <OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env | Scope.Scope> => Effect.scopeWith((scope) => executor.runIn(self, scope))\n\n/** @internal */\nexport const scoped = <A, E, R>(\n  effect: Effect.Effect<A, E, R>\n): Channel.Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>> =>\n  unwrap(\n    Effect.uninterruptibleMask((restore) =>\n      Effect.map(Scope.make(), (scope) =>\n        core.acquireReleaseOut(\n          Effect.tapErrorCause(\n            restore(Scope.extend(effect, scope)),\n            (cause) => Scope.close(scope, Exit.failCause(cause))\n          ),\n          (_, exit) => Scope.close(scope, exit)\n        ))\n    )\n  )\n\n/** @internal */\nexport const scopedWith = <A, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>\n): Channel.Channel<A, unknown, E, unknown, unknown, unknown, R> =>\n  unwrapScoped(Effect.map(Effect.scope, (scope) => core.flatMap(core.fromEffect(f(scope)), core.write)))\n\n/** @internal */\nexport const service = <T extends Context.Tag<any, any>>(\n  tag: T\n): Channel.Channel<never, unknown, never, unknown, Context.Tag.Service<T>, unknown, Context.Tag.Identifier<T>> =>\n  core.fromEffect(tag)\n\n/** @internal */\nexport const serviceWith = <T extends Context.Tag<any, any>>(tag: T) =>\n<OutDone>(\n  f: (resource: Context.Tag.Service<T>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, Context.Tag.Identifier<T>> => map(service(tag), f)\n\n/** @internal */\nexport const serviceWithChannel =\n  <T extends Context.Tag<any, any>>(tag: T) =>\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n    f: (resource: Context.Tag.Service<T>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Context.Tag.Identifier<T>> =>\n    core.flatMap(service(tag), f)\n\n/** @internal */\nexport const serviceWithEffect = <T extends Context.Tag<any, any>>(tag: T) =>\n<Env, OutErr, OutDone>(\n  f: (resource: Context.Tag.Service<T>) => Effect.Effect<OutDone, OutErr, Env>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Context.Tag.Identifier<T>> =>\n  mapEffect(service(tag), f)\n\n/** @internal */\nexport const splitLines = <Err, Done>(): Channel.Channel<\n  Chunk.Chunk<string>,\n  Chunk.Chunk<string>,\n  Err,\n  Err,\n  Done,\n  Done,\n  never\n> =>\n  core.suspend(() => {\n    let stringBuilder = \"\"\n    let midCRLF = false\n    const splitLinesChunk = (chunk: Chunk.Chunk<string>): Chunk.Chunk<string> => {\n      const chunkBuilder: Array<string> = []\n      Chunk.map(chunk, (str) => {\n        if (str.length !== 0) {\n          let from = 0\n          let indexOfCR = str.indexOf(\"\\r\")\n          let indexOfLF = str.indexOf(\"\\n\")\n          if (midCRLF) {\n            if (indexOfLF === 0) {\n              chunkBuilder.push(stringBuilder)\n              stringBuilder = \"\"\n              from = 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              stringBuilder = stringBuilder + \"\\r\"\n            }\n            midCRLF = false\n          }\n          while (indexOfCR !== -1 || indexOfLF !== -1) {\n            if (indexOfCR === -1 || (indexOfLF !== -1 && indexOfLF < indexOfCR)) {\n              if (stringBuilder.length === 0) {\n                chunkBuilder.push(str.substring(from, indexOfLF))\n              } else {\n                chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF))\n                stringBuilder = \"\"\n              }\n              from = indexOfLF + 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              if (str.length === indexOfCR + 1) {\n                midCRLF = true\n                indexOfCR = -1\n              } else {\n                if (indexOfLF === indexOfCR + 1) {\n                  if (stringBuilder.length === 0) {\n                    chunkBuilder.push(str.substring(from, indexOfCR))\n                  } else {\n                    stringBuilder = stringBuilder + str.substring(from, indexOfCR)\n                    chunkBuilder.push(stringBuilder)\n                    stringBuilder = \"\"\n                  }\n                  from = indexOfCR + 2\n                  indexOfCR = str.indexOf(\"\\r\", from)\n                  indexOfLF = str.indexOf(\"\\n\", from)\n                } else {\n                  indexOfCR = str.indexOf(\"\\r\", indexOfCR + 1)\n                }\n              }\n            }\n          }\n          if (midCRLF) {\n            stringBuilder = stringBuilder + str.substring(from, str.length - 1)\n          } else {\n            stringBuilder = stringBuilder + str.substring(from, str.length)\n          }\n        }\n      })\n      return Chunk.unsafeFromArray(chunkBuilder)\n    }\n    const loop: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never> = core\n      .readWithCause({\n        onInput: (input: Chunk.Chunk<string>) => {\n          const out = splitLinesChunk(input)\n          return Chunk.isEmpty(out)\n            ? loop\n            : core.flatMap(core.write(out), () => loop)\n        },\n        onFailure: (cause) =>\n          stringBuilder.length === 0\n            ? core.failCause(cause)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.failCause(cause)),\n        onDone: (done) =>\n          stringBuilder.length === 0\n            ? core.succeed(done)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.succeed(done))\n      })\n    return loop\n  })\n\n/** @internal */\nexport const toPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => toQueue(pubsub)\n\n/** @internal */\nexport const toPull = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env | Scope.Scope> =>\n  Effect.flatMap(Effect.scope, (scope) => toPullIn(self, scope))\n\n/** @internal */\nexport const toPullIn = dual<\n  (scope: Scope.Scope) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    scope: Scope.Scope\n  ) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  scope: Scope.Scope\n) =>\n  Effect.zip(\n    Effect.sync(() => new executor.ChannelExecutor(self, void 0, identity)),\n    Effect.runtime<Env>()\n  ).pipe(\n    Effect.tap(([executor, runtime]) =>\n      Scope.addFinalizerExit(scope, (exit) => {\n        const finalizer = executor.close(exit)\n        return finalizer !== undefined\n          ? Effect.provide(finalizer, runtime)\n          : Effect.void\n      })\n    ),\n    Effect.uninterruptible,\n    Effect.map(([executor]) =>\n      Effect.suspend(() =>\n        interpretToPull(\n          executor.run() as ChannelState.ChannelState<OutErr, Env>,\n          executor\n        )\n      )\n    )\n  ))\n\n/** @internal */\nconst interpretToPull = <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n  channelState: ChannelState.ChannelState<OutErr, Env>,\n  exec: executor.ChannelExecutor<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> => {\n  const state = channelState as ChannelState.Primitive\n  switch (state._tag) {\n    case ChannelStateOpCodes.OP_DONE: {\n      return Exit.match(exec.getDone(), {\n        onFailure: Effect.failCause,\n        onSuccess: (done): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> =>\n          Effect.succeed(Either.left(done))\n      })\n    }\n    case ChannelStateOpCodes.OP_EMIT: {\n      return Effect.succeed(Either.right(exec.getEmit()))\n    }\n    case ChannelStateOpCodes.OP_FROM_EFFECT: {\n      return pipe(\n        state.effect as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>,\n        Effect.flatMap(() => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec))\n      )\n    }\n    case ChannelStateOpCodes.OP_READ: {\n      return executor.readUpstream(\n        state,\n        () => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec),\n        (cause) => Effect.failCause(cause) as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>\n      )\n    }\n  }\n}\n\n/** @internal */\nexport const toQueue = <Done, Err, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => core.suspend(() => toQueueInternal(queue))\n\n/** @internal */\nconst toQueueInternal = <Err, Done, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => {\n  return core.readWithCause({\n    onInput: (elem) =>\n      core.flatMap(\n        core.fromEffect(Queue.offer(queue, Either.right(elem))),\n        () => toQueueInternal(queue)\n      ),\n    onFailure: (cause) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.failCause(cause))))),\n    onDone: (done) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.succeed(done)))))\n  })\n}\n\n/** @internal */\nexport const unwrap = <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(\n  channel: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2> => flatten(core.fromEffect(channel))\n\n/** @internal */\nexport const unwrapScoped = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(\n  self: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>> =>\n  core.concatAllWith(\n    scoped(self),\n    (d, _) => d,\n    (d, _) => d\n  )\n\n/** @internal */\nexport const unwrapScopedWith = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env> =>\n  core.concatAllWith(\n    scopedWith(f),\n    (d, _) => d,\n    (d, _) => d\n  )\n\n/** @internal */\nexport const updateService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, T | R>,\n  <OutElem, OutErr, InErr, OutDone, InDone, R, T extends Context.Tag<any, any>>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n    tag: T,\n    f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, T | R>\n>(3, <OutElem, OutErr, InErr, OutDone, InDone, R, T extends Context.Tag<any, any>>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n  tag: T,\n  f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n): Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R | T> =>\n  mapInputContext(self, (context: Context.Context<R>) =>\n    Context.merge(\n      context,\n      Context.make(tag, f(Context.unsafeGet(context, tag)))\n    )))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions\n  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    name: string,\n    options?: Tracer.SpanOptions\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  const acquire = Effect.all([\n    Effect.makeSpan(name, options),\n    Effect.context(),\n    Effect.clock,\n    FiberRef.get(FiberRef.currentTracerTimingEnabled)\n  ])\n  if (dataFirst) {\n    const self = arguments[0]\n    return acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n  }\n  return (self: Channel.Channel<any>) =>\n    acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n} as any\n\n/** @internal */\nexport const writeAll = <OutElem>(\n  ...outs: Array<OutElem>\n): Channel.Channel<OutElem> => writeChunk(Chunk.fromIterable(outs))\n\n/** @internal */\nexport const writeChunk = <OutElem>(\n  outs: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => writeChunkWriter(0, outs.length, outs)\n\n/** @internal */\nconst writeChunkWriter = <OutElem>(\n  idx: number,\n  len: number,\n  chunk: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => {\n  return idx === len\n    ? core.void\n    : pipe(\n      core.write(pipe(chunk, Chunk.unsafeGet(idx))),\n      core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))\n    )\n}\n\n/** @internal */\nexport const zip = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      mergeWith(self, {\n        other: that,\n        onSelfDone: (exit1) => mergeDecision.Await((exit2) => Effect.suspend(() => Exit.zip(exit1, exit2))),\n        onOtherDone: (exit2) => mergeDecision.Await((exit1) => Effect.suspend(() => Exit.zip(exit1, exit2)))\n      }) :\n      core.flatMap(self, (a) => map(that, (b) => [a, b] as const))\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[0]) :\n      core.flatMap(self, (z) => as(that, z))\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[1]) :\n      core.flatMap(self, () => that)\n)\n\n/** @internal */\nexport const ChannelExceptionTypeId: Channel.ChannelExceptionTypeId = Symbol.for(\n  \"effect/Channel/ChannelException\"\n) as Channel.ChannelExceptionTypeId\n\n/** @internal */\nexport const ChannelException = <E>(error: E): Channel.ChannelException<E> => ({\n  _tag: \"ChannelException\",\n  [ChannelExceptionTypeId]: ChannelExceptionTypeId,\n  error\n})\n\n/** @internal */\nexport const isChannelException = (u: unknown): u is Channel.ChannelException<unknown> =>\n  hasProperty(u, ChannelExceptionTypeId)\n"],"names":["Cause","Chunk","Context","Deferred","Effect","Either","Equal","Exit","Fiber","FiberRef","constVoid","dual","identity","pipe","Layer","Option","hasProperty","PubSub","Queue","Ref","Scope","executor","mergeDecision","mergeState","_mergeStrategy","singleProducerAsyncInput","coreEffect","core","MergeDecisionOpCodes","MergeStateOpCodes","ChannelStateOpCodes","tracer","acquireUseRelease","acquire","use","release","flatMap","fromEffect","make","void","ref","uninterruptible","tap","a","set","exit","ensuringWith","get","f","as","self","value","map","asVoid","buffer","options","suspend","doBuffer","empty","isEmpty","unwrap","modify","inElem","readWith","onInput","input","write","onFailure","error","fail","onDone","done","succeedNow","bufferChunk","catchAll","catchAllCause","cause","match","failureOrCause","onLeft","onRight","failCause","concatMap","concatMapWith","collect","pf","collector","out","onNone","onSome","out2","pipeTo","concatOut","concatAll","mapInput","reader","mapInputEffect","mapInputError","mapInputErrorEffect","mapInputIn","mapInputInEffect","doneCollect","builder","doneCollectReader","outDone","succeed","unsafeFromArray","outElem","sync","push","drain","drainer","readWithCause","emitCollect","ensuring","finalizer","context","contextWith","contextWithChannel","contextWithEffect","mapEffect","flatten","foldChannel","foldCauseChannel","either","_tag","left","right","onSuccess","fromEither","fromInput","takeWith","elem","fromPubSub","pubsub","unwrapScoped","subscribe","fromQueue","fromPubSubScoped","fromOption","option","none","queue","fromQueueInternal","take","identityChannel","interruptWhen","effect","mergeWith","other","onSelfDone","selfDone","Done","onOtherDone","effectDone","interruptWhenDeferred","deferred","await","z","mapError","mapErrorCause","mapOut","mapOutEffect","mapOutEffectPar","n","unwrapScopedWith","scope","gen","queueReader","bounded","addFinalizer","shutdown","errorSignal","withPermits","Number","POSITIVE_INFINITY","_","makeSemaphore","pull","toPullIn","matchCauseEffect","offer","zipRight","interruptible","latch","uninterruptibleMask","restore","raceFirst","tapErrorCause","intoDeferred","forkIn","forever","consumer","matchCause","embedInput","mergeAll","channels","mergeAllWith","mergeAllUnbounded","concurrency","mergeAllUnboundedWith","bufferSize","mergeStrategy","BackPressure","concurrencyN","MAX_SAFE_INTEGER","cancelers","unbounded","lastDone","evaluatePull","some","repeat","until","isSome","update","isInterrupted","raceWith","permitAcquisition","interrupt","failureAwait","channel","onBackPressure","raceEffects","scopedWith","race","errored","isDone","onBufferSliding","canceler","size","when","while","mergeMap","mergeOut","mergeOutWith","merge","pullL","pullR","handleSide","fiber","both","single","onDecision","decision","op","OP_DONE","go","leftFiber","state","OP_BOTH_RUNNING","leftJoin","join","rightJoin","leftExit","rf","BothRunning","LeftDone","rightExit","lf","RightDone","OP_LEFT_DONE","OP_RIGHT_DONE","withFiberRuntime","parent","inherit","transferChildren","rightFiber","zipWith","never","orDie","orDieWith","e","orElse","that","pipeToOrFail","channelException","undefined","outErr","ChannelException","die","writer","isDieType","isChannelException","defect","equals","provideService","tag","service","provideContext","add","provideLayer","layer","buildWithScope","mapInputContext","provideSomeLayer","read","readOrFail","repeated","run","runIn","runCollect","collectElements","runDrain","runScoped","scopeWith","scoped","acquireReleaseOut","extend","close","serviceWith","serviceWithChannel","serviceWithEffect","splitLines","stringBuilder","midCRLF","splitLinesChunk","chunk","chunkBuilder","str","length","from","indexOfCR","indexOf","indexOfLF","substring","loop","of","toPubSub","toQueue","toPull","zip","ChannelExecutor","runtime","addFinalizerExit","provide","interpretToPull","channelState","exec","getDone","OP_EMIT","getEmit","OP_FROM_EFFECT","OP_READ","readUpstream","toQueueInternal","concatAllWith","d","updateService","unsafeGet","withSpan","dataFirst","arguments","name","addSpanStackTrace","all","makeSpan","clock","currentTracerTimingEnabled","span","spanTag","timingEnabled","endSpan","writeAll","outs","writeChunk","fromIterable","writeChunkWriter","idx","len","args","isChannel","concurrent","exit1","Await","exit2","b","zipLeft","tuple","ChannelExceptionTypeId","Symbol","for","u"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}