{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"core.js","sources":["file:///home/yurtur/projects/candle-constructor/node_modules/effect/src/internal/core.ts"],"sourcesContent":["import { internalCall } from \"effect/Utils\"\nimport * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport type * as Differ from \"../Differ.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport type * as LogSpan from \"../LogSpan.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, isObject, isPromiseLike, type Predicate, type Refinement } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as BlockedRequests from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { NoInfer, NotFunction } from \"../Types.js\"\nimport { YieldWrap } from \"../Utils.js\"\nimport * as _blockedRequests from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as deferred from \"./deferred.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\nimport type * as fiberScope from \"./fiberScope.js\"\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as _runtimeFlags from \"./runtimeFlags.js\"\nimport { SingleShotGen } from \"./singleShotGen.js\"\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst EffectErrorSymbolKey = \"effect/EffectError\"\n\n/** @internal */\nexport const EffectErrorTypeId = Symbol.for(EffectErrorSymbolKey)\n\n/** @internal */\nexport type EffectErrorTypeId = typeof EffectErrorTypeId\n\n/** @internal */\nexport interface EffectError<out E> {\n  readonly [EffectErrorTypeId]: EffectErrorTypeId\n  readonly _tag: \"EffectError\"\n  readonly cause: Cause.Cause<E>\n}\n\n/** @internal */\nexport const isEffectError = (u: unknown): u is EffectError<unknown> => hasProperty(u, EffectErrorTypeId)\n\n/** @internal */\nexport const makeEffectError = <E>(cause: Cause.Cause<E>): EffectError<E> => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n})\n\n/**\n * @internal\n */\nexport const blocked = <A, E>(\n  blockedRequests: BlockedRequests.RequestBlock,\n  _continue: Effect.Effect<A, E>\n): Effect.Blocked<A, E> => {\n  const effect = new EffectPrimitive(\"Blocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  effect.effect_instruction_i1 = _continue\n  return effect\n}\n\n/**\n * @internal\n */\nexport const runRequestBlock = (\n  blockedRequests: BlockedRequests.RequestBlock\n): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(\"RunBlocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  return effect\n}\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport type Primitive =\n  | Async\n  | Commit\n  | Failure\n  | OnFailure\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | Success\n  | Sync\n  | UpdateRuntimeFlags\n  | While\n  | FromIterator\n  | WithRuntime\n  | Yield\n  | OpTag\n  | Blocked\n  | RunBlocked\n  | Either.Either<any, any>\n  | Option.Option<any>\n\n/** @internal */\nexport type Continuation =\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | OnFailure\n  | While\n  | FromIterator\n  | RevertFlags\n\n/** @internal */\nexport class RevertFlags {\n  readonly _op = OpCodes.OP_REVERT_FLAGS\n  constructor(\n    readonly patch: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    readonly op: Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }\n  ) {\n  }\n}\n\nclass EffectPrimitive {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {}\n  [Equal.symbol](this: {}, that: unknown) {\n    return this === that\n  }\n  [Hash.symbol](this: {}) {\n    return Hash.cached(this, Hash.random(this))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get cause() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: (this.cause as any).toJSON()\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get value() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Effect.Effect<never> & Body & {\n  readonly _op: Tag\n}\n\n/** @internal */\nexport interface Async extends\n  Op<OpCodes.OP_ASYNC, {\n    effect_instruction_i0(resume: (effect: Primitive) => void): void\n    readonly effect_instruction_i1: FiberId.FiberId\n  }>\n{}\n\n/** @internal */\nexport interface Blocked<out E = any, out A = any> extends\n  Op<\"Blocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n    readonly effect_instruction_i1: Effect.Effect<A, E>\n  }>\n{}\n\n/** @internal */\nexport interface RunBlocked extends\n  Op<\"RunBlocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n  }>\n{}\n\n/** @internal */\nexport interface Failure extends\n  Op<OpCodes.OP_FAILURE, {\n    readonly effect_instruction_i0: Cause.Cause<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OpTag extends Op<OpCodes.OP_TAG, {}> {}\n\n/** @internal */\nexport interface Commit extends\n  Op<OpCodes.OP_COMMIT, {\n    commit(): Effect.Effect<unknown, unknown, unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OnFailure extends\n  Op<OpCodes.OP_ON_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnSuccess extends\n  Op<OpCodes.OP_ON_SUCCESS, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnStep extends Op<\"OnStep\", { readonly effect_instruction_i0: Primitive }> {}\n\n/** @internal */\nexport interface OnSuccessAndFailure extends\n  Op<OpCodes.OP_ON_SUCCESS_AND_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n    effect_instruction_i2(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Success extends\n  Op<OpCodes.OP_SUCCESS, {\n    readonly effect_instruction_i0: unknown\n  }>\n{}\n\n/** @internal */\nexport interface Sync extends\n  Op<OpCodes.OP_SYNC, {\n    effect_instruction_i0(): unknown\n  }>\n{}\n\n/** @internal */\nexport interface UpdateRuntimeFlags extends\n  Op<OpCodes.OP_UPDATE_RUNTIME_FLAGS, {\n    readonly effect_instruction_i0: RuntimeFlagsPatch.RuntimeFlagsPatch\n    readonly effect_instruction_i1?: (oldRuntimeFlags: RuntimeFlags.RuntimeFlags) => Primitive\n  }>\n{}\n\n/** @internal */\nexport interface While extends\n  Op<OpCodes.OP_WHILE, {\n    effect_instruction_i0(): boolean\n    effect_instruction_i1(): Primitive\n    effect_instruction_i2(a: unknown): void\n  }>\n{}\n\n/** @internal */\nexport interface FromIterator extends\n  Op<OpCodes.OP_ITERATOR, {\n    effect_instruction_i0: Iterator<YieldWrap<Primitive>, any>\n  }>\n{}\n\n/** @internal */\nexport interface WithRuntime extends\n  Op<OpCodes.OP_WITH_RUNTIME, {\n    effect_instruction_i0(fiber: FiberRuntime.FiberRuntime<unknown, unknown>, status: FiberStatus.Running): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Yield extends Op<OpCodes.OP_YIELD> {}\n\n/** @internal */\nexport const isEffect = (u: unknown): u is Effect.Effect<unknown, unknown, unknown> => hasProperty(u, EffectTypeId)\n\n/* @internal */\nexport const withFiberRuntime = <A, E = never, R = never>(\n  withRuntime: (fiber: FiberRuntime.FiberRuntime<A, E>, status: FiberStatus.Running) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME) as any\n  effect.effect_instruction_i0 = withRuntime\n  return effect\n}\n\n/* @internal */\nexport const acquireUseRelease: {\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): Effect.Effect<A2, E | E2, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, X, R3>(\n  acquire: Effect.Effect<A, E, R>,\n  use: (a: A) => Effect.Effect<A2, E2, R2>,\n  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n): Effect.Effect<A2, E | E2, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(exit(suspend(() => restore(use(a)))), (exit): Effect.Effect<A2, E | E2, R | R2 | R3> => {\n          return suspend(() => release(a, exit)).pipe(\n            matchCauseEffect({\n              onFailure: (cause) => {\n                switch (exit._tag) {\n                  case OpCodes.OP_FAILURE:\n                    return failCause(internalCause.sequential(exit.effect_instruction_i0, cause))\n                  case OpCodes.OP_SUCCESS:\n                    return failCause(cause)\n                }\n              },\n              onSuccess: () => exit\n            })\n          )\n        })\n    )\n  ))\n\n/* @internal */\nexport const as: {\n  <B>(value: B): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R> => flatMap(self, () => succeed(value))\n)\n\n/* @internal */\nexport const asVoid = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, E, R> => as(self, void 0)\n\n/* @internal */\nexport const custom: {\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (\n      this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = function() {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  switch (arguments.length) {\n    case 2: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.commit = arguments[1]\n      break\n    }\n    case 3: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.commit = arguments[2]\n      break\n    }\n    case 4: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.effect_instruction_i2 = arguments[2]\n      wrapper.commit = arguments[3]\n      break\n    }\n    default: {\n      throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"))\n    }\n  }\n  return wrapper\n}\n\n/* @internal */\nexport const unsafeAsync = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n  let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n  effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n    cancelerRef = register(resume)\n  }\n  effect.effect_instruction_i1 = blockingOn\n  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_)\n}\n\n/* @internal */\nexport const asyncInterrupt = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => suspend(() => unsafeAsync(register, blockingOn))\n\nconst async_ = <A, E = never, R = never>(\n  resume: (\n    callback: (_: Effect.Effect<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  return custom(resume, function() {\n    let backingResume: ((_: Effect.Effect<A, E, R>) => void) | undefined = undefined\n    let pendingEffect: Effect.Effect<A, E, R> | undefined = undefined\n    function proxyResume(effect: Effect.Effect<A, E, R>) {\n      if (backingResume) {\n        backingResume(effect)\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n    effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n      backingResume = resume\n      if (pendingEffect) {\n        resume(pendingEffect)\n      }\n    }\n    effect.effect_instruction_i1 = blockingOn\n    let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n    let controllerRef: AbortController | void = undefined\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController()\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef!.signal))\n    } else {\n      cancelerRef = internalCall(() => (this.effect_instruction_i0 as any)(proxyResume))\n    }\n    return (cancelerRef || controllerRef) ?\n      onInterrupt(effect, (_) => {\n        if (controllerRef) {\n          controllerRef.abort()\n        }\n        return cancelerRef ?? void_\n      }) :\n      effect\n  })\n}\nexport {\n  /** @internal */\n  async_ as async\n}\n\n/* @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2, R2 | R>\n>(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = f\n  return effect\n})\n\n/* @internal */\nexport const catchAll: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => matchEffect(self, { onFailure: f, onSuccess: succeed })\n)\n\n/* @internal */\nexport const catchIf: {\n  <E, EB extends E, A2, E2, R2>(\n    refinement: Refinement<NoInfer<E>, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <E, A2, E2, R2>(\n    predicate: Predicate<NoInfer<E>>,\n    f: (e: NoInfer<E>) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A | A2, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate<E>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  catchAllCause(self, (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return predicate(either.left) ? f(either.left) : failCause(cause)\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A2 | A, E | E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n) =>\n  catchAllCause(self, (cause): Effect.Effect<A2 | A, E | E2, R2 | R> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)))\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const checkInterruptible = <A, E, R>(\n  f: (isInterruptible: boolean) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((_, status) => f(_runtimeFlags.interruption(status.runtimeFlags)))\n\nconst spanSymbol = Symbol.for(\"effect/SpanAnnotation\")\nconst originalSymbol = Symbol.for(\"effect/OriginalAnnotation\")\n\n/* @internal */\nexport const originalInstance = <E>(obj: E): E => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol]\n  }\n  return obj\n}\n\n/* @internal */\nexport const capture = <E>(obj: E & object, span: Option.Option<Tracer.Span>): E => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === spanSymbol || p === originalSymbol || p in target\n      },\n      get(target, p) {\n        if (p === spanSymbol) {\n          return span.value\n        }\n        if (p === originalSymbol) {\n          return obj\n        }\n        // @ts-expect-error\n        return target[p]\n      }\n    })\n  }\n  return obj\n}\n\n/* @internal */\nexport const die = (defect: unknown): Effect.Effect<never> =>\n  isObject(defect) && !(spanSymbol in defect) ?\n    withFiberRuntime((fiber) => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.die(defect))\n\n/* @internal */\nexport const dieMessage = (message: string): Effect.Effect<never> =>\n  failCauseSync(() => internalCause.die(new RuntimeException(message)))\n\n/* @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Effect.Effect<never> => flatMap(sync(evaluate), die)\n\n/* @internal */\nexport const either = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Either.Either<A, E>, never, R> =>\n  matchEffect(self, {\n    onFailure: (e) => succeed(Either.left(e)),\n    onSuccess: (a) => succeed(Either.right(a))\n  })\n\n/* @internal */\nexport const exit = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Exit.Exit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/* @internal */\nexport const fail = <E>(error: E): Effect.Effect<never, E> =>\n  isObject(error) && !(spanSymbol in error) ?\n    withFiberRuntime((fiber) => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.fail(error))\n\n/* @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Effect.Effect<never, E> => flatMap(sync(evaluate), fail)\n\n/* @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Effect.Effect<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/* @internal */\nexport const failCauseSync = <E>(\n  evaluate: LazyArg<Cause.Cause<E>>\n): Effect.Effect<never, E> => flatMap(sync(evaluate), failCause)\n\n/* @internal */\nexport const fiberId: Effect.Effect<FiberId.FiberId> = withFiberRuntime((state) => succeed(state.id()))\n\n/* @internal */\nexport const fiberIdWith = <A, E, R>(\n  f: (descriptor: FiberId.Runtime) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((state) => f(state.id()))\n\n/* @internal */\nexport const flatMap = dual<\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => Effect.Effect<B, E | E1, R | R1>\n>(\n  2,\n  (self, f) => {\n    const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS) as any\n    effect.effect_instruction_i0 = self\n    effect.effect_instruction_i1 = f\n    return effect\n  }\n)\n\n/* @internal */\nexport const andThen: {\n  <A, X>(\n    f: (a: NoInfer<A>) => X\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <X>(\n    f: NotFunction<X>\n  ): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: NoInfer<A>) => X\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: NotFunction<X>\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n} = dual(2, (self, f) =>\n  flatMap(self, (a) => {\n    const b = typeof f === \"function\" ? (f as any)(a) : f\n    if (isEffect(b)) {\n      return b\n    } else if (isPromiseLike(b)) {\n      return unsafeAsync<any, Cause.UnknownException>((resume) => {\n        b.then((a) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n      })\n    }\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const step = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Exit.Exit<A, E> | Effect.Blocked<A, E>, never, R> => {\n  const effect = new EffectPrimitive(\"OnStep\") as any\n  effect.effect_instruction_i0 = self\n  return effect\n}\n\n/* @internal */\nexport const flatten = <A, E1, R1, E, R>(\n  self: Effect.Effect<Effect.Effect<A, E1, R1>, E, R>\n): Effect.Effect<A, E | E1, R | R1> => flatMap(self, identity)\n\n/* @internal */\nexport const flip = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E, A, R> =>\n  matchEffect(self, { onFailure: succeed, onSuccess: fail })\n\n/* @internal */\nexport const matchCause: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => A2\n    readonly onSuccess: (a: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => succeed(options.onFailure(cause)),\n    onSuccess: (a) => succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const matchCauseEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = options.onFailure\n  effect.effect_instruction_i2 = options.onSuccess\n  return effect\n})\n\n/* @internal */\nexport const matchEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(internalCause.electFailures(cause))\n      }\n      const failures = internalCause.failures(cause)\n      if (failures.length > 0) {\n        return options.onFailure(Chunk.unsafeHead(failures))\n      }\n      return failCause(cause as Cause.Cause<never>)\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/* @internal */\nexport const forEachSequential: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      const ret = Arr.allocate<B>(arr.length)\n      let i = 0\n      return as(\n        whileLoop({\n          while: () => i < arr.length,\n          body: () => f(arr[i], i),\n          step: (b) => {\n            ret[i++] = b\n          }\n        }),\n        ret as Array<B>\n      )\n    })\n)\n\n/* @internal */\nexport const forEachSequentialDiscard: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      let i = 0\n      return whileLoop({\n        while: () => i < arr.length,\n        body: () => f(arr[i], i),\n        step: () => {\n          i++\n        }\n      })\n    })\n)\n\n/* @internal */\nexport const if_ = dual<\n  <A1, E1, R1, A2, E2, R2>(\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => <E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean\n  ) => Effect.Effect<A1 | A2, E | E1 | E2, R | R1 | R2>,\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n>(\n  (args) => typeof args[0] === \"boolean\" || isEffect(args[0]),\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ): Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R> =>\n    isEffect(self)\n      ? flatMap(self, (b): Effect.Effect<A1 | A2, E1 | E2, R1 | R2> => (b ? options.onTrue() : options.onFalse()))\n      : self\n      ? options.onTrue()\n      : options.onFalse()\n)\n\n/* @internal */\nexport const interrupt: Effect.Effect<never> = flatMap(fiberId, (fiberId) => interruptWith(fiberId))\n\n/* @internal */\nexport const interruptWith = (fiberId: FiberId.FiberId): Effect.Effect<never> =>\n  failCause(internalCause.interrupt(fiberId))\n\n/* @internal */\nexport const interruptible = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const interruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\n/* @internal */\nexport const intoDeferred: {\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<boolean, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(\n        exit(restore(self)),\n        (exit) => deferredDone(deferred, exit)\n      )\n    )\n)\n\n/* @internal */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> =>\n    flatMap(self, (a) => sync(() => f(a)))\n)\n\n/* @internal */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> =>\n  matchEffect(self, {\n    onFailure: (e) => failSync(() => options.onFailure(e)),\n    onSuccess: (a) => sync(() => options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => {\n        const either = internalCause.failureOrCause(cause)\n        switch (either._tag) {\n          case \"Left\": {\n            return failSync(() => f(either.left))\n          }\n          case \"Right\": {\n            return failCause(either.right)\n          }\n        }\n      },\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const onError: {\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(self, (exit) => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)))\n\n/* @internal */\nexport const onExit: {\n  <A, E, X, R2>(\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  uninterruptibleMask((restore) =>\n    matchCauseEffect(restore(self), {\n      onFailure: (cause1) => {\n        const result = exitFailCause(cause1)\n        return matchCauseEffect(cleanup(result), {\n          onFailure: (cause2) => exitFailCause(internalCause.sequential(cause1, cause2)),\n          onSuccess: () => result\n        })\n      },\n      onSuccess: (success) => {\n        const result = exitSucceed(success)\n        return zipRight(cleanup(result), result)\n      }\n    })\n  ))\n\n/* @internal */\nexport const onInterrupt: {\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(\n    self,\n    exitMatch({\n      onFailure: (cause) =>\n        internalCause.isInterruptedOnly(cause)\n          ? asVoid(cleanup(internalCause.interruptors(cause)))\n          : void_,\n      onSuccess: () => void_\n    })\n  ))\n\n/* @internal */\nexport const orElse: {\n  <A2, E2, R2>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => attemptOrElse(self, that, succeed)\n)\n\n/* @internal */\nexport const orDie = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> => orDieWith(self, identity)\n\n/* @internal */\nexport const orDieWith: {\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R> =>\n    matchEffect(self, {\n      onFailure: (e) => die(f(e)),\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const partitionMap: <A, A1, A2>(\n  elements: Iterable<A>,\n  f: (a: A) => Either.Either<A2, A1>\n) => [left: Array<A1>, right: Array<A2>] = Arr.partitionMap\n/* @internal */\nexport const runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags> = withFiberRuntime((_, status) =>\n  succeed(status.runtimeFlags)\n)\n\n/* @internal */\nexport const succeed = <A>(value: A): Effect.Effect<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/* @internal */\nexport const suspend = <A, E, R>(evaluate: LazyArg<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  effect.commit = evaluate\n  return effect\n}\n\n/* @internal */\nexport const sync = <A>(thunk: LazyArg<A>): Effect.Effect<A> => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC) as any\n  effect.effect_instruction_i0 = thunk\n  return effect\n}\n\n/* @internal */\nexport const tap = dual<\n  {\n    <A, X>(\n      f: (a: NoInfer<A>) => X\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, X, E1, R1>(\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n    <X>(\n      f: NotFunction<X>\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <X, E1, R1>(\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n  },\n  {\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => X\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: NotFunction<X>\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n  }\n>(\n  (args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]),\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, f: X) =>\n    flatMap(self, (a) => {\n      const b = typeof f === \"function\" ? (f as any)(a) : f\n      if (isEffect(b)) {\n        return as(b, a)\n      } else if (isPromiseLike(b)) {\n        return unsafeAsync<any, Cause.UnknownException>((resume) => {\n          b.then((_) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n        })\n      }\n      return succeed(a)\n    })\n)\n\n/* @internal */\nexport const transplant = <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  withFiberRuntime<A, E, R>((state) => {\n    const scopeOverride = state.getFiberRef(currentForkScopeOverride)\n    const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()))\n    return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)))\n  })\n\n/* @internal */\nexport const attemptOrElse: {\n  <A2, E2, R2, A, A3, E3, R3>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  that: LazyArg<Effect.Effect<A2, E2, R2>>,\n  onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)))\n      }\n      return that()\n    },\n    onSuccess\n  }))\n\n/* @internal */\nexport const uninterruptible: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\nconst void_: Effect.Effect<void> = succeed(void 0)\nexport {\n  /* @internal */\n  void_ as void\n}\n\n/* @internal */\nexport const updateRuntimeFlags = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = patch\n  effect.effect_instruction_i1 = void 0\n  return effect\n}\n\n/* @internal */\nexport const whenEffect: {\n  <E, R>(\n    condition: Effect.Effect<boolean, E, R>\n  ): <A, E2, R2>(\n    effect: Effect.Effect<A, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n  <A, E2, R2, E, R>(\n    self: Effect.Effect<A, E2, R2>,\n    condition: Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E | E2, R | R2>\n} = dual(2, <A, E2, R2, E, R>(\n  self: Effect.Effect<A, E2, R2>,\n  condition: Effect.Effect<boolean, E, R>\n): Effect.Effect<Option.Option<A>, E | E2, R | R2> =>\n  flatMap(condition, (b) => {\n    if (b) {\n      return pipe(self, map(Option.some))\n    }\n    return succeed(Option.none())\n  }))\n\n/* @internal */\nexport const whileLoop = <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect.Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n): Effect.Effect<void, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE) as any\n  effect.effect_instruction_i0 = options.while\n  effect.effect_instruction_i1 = options.body\n  effect.effect_instruction_i2 = options.step\n  return effect\n}\n\n/* @internal */\nexport const gen: typeof Effect.gen = function() {\n  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0])\n  return suspend(() => {\n    const effect = new EffectPrimitive(OpCodes.OP_ITERATOR) as any\n    effect.effect_instruction_i0 = f(pipe)\n    return effect\n  })\n}\n\n/* @internal */\nexport const withConcurrency = dual<\n  (concurrency: number | \"unbounded\") => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, concurrency: number | \"unbounded\") => Effect.Effect<A, E, R>\n>(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency))\n\n/* @internal */\nexport const withRequestBatching = dual<\n  (requestBatching: boolean) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, requestBatching: boolean) => Effect.Effect<A, E, R>\n>(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching))\n\n/* @internal */\nexport const withRuntimeFlags = dual<\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect.Effect<A, E, R>\n>(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = update\n  effect.effect_instruction_i1 = () => self\n  return effect\n})\n\n/** @internal */\nexport const withTracerEnabled = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerEnabled,\n    enabled\n  ))\n\n/** @internal */\nexport const withTracerTiming = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerTimingEnabled,\n    enabled\n  ))\n\n/* @internal */\nexport const yieldNow = (options?: {\n  readonly priority?: number | undefined\n}): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD) as any\n  return typeof options?.priority !== \"undefined\" ?\n    withSchedulingPriority(effect, options.priority) :\n    effect\n}\n\n/* @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [a, b])))\n\n/* @internal */\nexport const zipFlatten: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A extends ReadonlyArray<any>, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[...A, A2], E | E2, R | R2>\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<[...A, A2], E | E2, R | R2>\n} = dual(2, <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[...A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [...a, b])))\n\n/* @internal */\nexport const zipLeft: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A, E | E2, R | R2> => flatMap(self, (a) => as(that, a)))\n\n/* @internal */\nexport const zipRight: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2> => flatMap(self, () => that))\n\n/* @internal */\nexport const zipWith: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E2, R | R2>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): Effect.Effect<B, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B\n): Effect.Effect<B, E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => f(a, b))))\n\n/* @internal */\nexport const never: Effect.Effect<never> = asyncInterrupt<never>(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1)\n  return sync(() => clearInterval(interval))\n})\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const interruptFiber = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> =>\n  flatMap(fiberId, (fiberId) => pipe(self, interruptAsFiber(fiberId)))\n\n/* @internal */\nexport const interruptAsFiber = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<Exit.Exit<A, E>>\n>(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await))\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const logLevelAll: LogLevel.LogLevel = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelFatal: LogLevel.LogLevel = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelError: LogLevel.LogLevel = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelWarning: LogLevel.LogLevel = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelInfo: LogLevel.LogLevel = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelDebug: LogLevel.LogLevel = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelTrace: LogLevel.LogLevel = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelNone: LogLevel.LogLevel = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const allLogLevels: ReadonlyArray<LogLevel.LogLevel> = [\n  logLevelAll,\n  logLevelTrace,\n  logLevelDebug,\n  logLevelInfo,\n  logLevelWarning,\n  logLevelError,\n  logLevelFatal,\n  logLevelNone\n]\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\"\n\n/** @internal */\nexport const FiberRefTypeId: FiberRef.FiberRefTypeId = Symbol.for(\n  FiberRefSymbolKey\n) as FiberRef.FiberRefTypeId\n\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/* @internal */\nexport const fiberRefGet = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<A> =>\n  withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)))\n\n/* @internal */\nexport const fiberRefGetAndSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<A>\n>(2, (self, value) => fiberRefModify(self, (v) => [v, value] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdateSome = dual<\n  <A>(\n    pf: (a: A) => Option.Option<A>\n  ) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    pf: (a: A) => Option.Option<A>\n  ) => Effect.Effect<A>\n>(2, (self, pf) => fiberRefModify(self, (v) => [v, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefGetWith = dual<\n  <B, E, R, A>(f: (a: A) => Effect.Effect<B, E, R>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(self: FiberRef.FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n>(2, (self, f) => flatMap(fiberRefGet(self), f))\n\n/* @internal */\nexport const fiberRefSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void>\n>(2, (self, value) => fiberRefModify(self, () => [void 0, value] as const))\n\n/* @internal */\nexport const fiberRefDelete = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> =>\n  withFiberRuntime((state) => {\n    state.unsafeDeleteFiberRef(self)\n    return void_\n  })\n\n/* @internal */\nexport const fiberRefReset = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> => fiberRefSet(self, self.initial)\n\n/* @internal */\nexport const fiberRefModify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B>,\n  <A, B>(self: FiberRef.FiberRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, <A, B>(\n  self: FiberRef.FiberRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> =>\n  withFiberRuntime((state) => {\n    const [b, a] = f(state.getFiberRef(self) as A)\n    state.setFiberRef(self, a)\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const fiberRefModifySome = <A, B>(\n  self: FiberRef.FiberRef<A>,\n  def: B,\n  f: (a: A) => Option.Option<readonly [B, A]>\n): Effect.Effect<B> => fiberRefModify(self, (v) => Option.getOrElse(f(v), () => [def, v] as const))\n\n/* @internal */\nexport const fiberRefUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, (self, pf) => fiberRefModify(self, (v) => [void 0, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) =>\n  fiberRefModify(self, (v) => {\n    const result = f(v)\n    return [result, result] as const\n  }))\n\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, (self, pf) =>\n  fiberRefModify(self, (v) => {\n    const result = Option.getOrElse(pf(v), () => v)\n    return [result, result] as const\n  }))\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\"\n\n/** @internal */\nexport const RequestResolverTypeId: RequestResolver.RequestResolverTypeId = Symbol.for(\n  RequestResolverSymbolKey\n) as RequestResolver.RequestResolverTypeId\n\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class RequestResolverImpl<in A, out R> implements RequestResolver.RequestResolver<A, R> {\n  readonly [RequestResolverTypeId] = requestResolverVariance\n  constructor(\n    readonly runAll: (\n      requests: Array<Array<Request.Entry<A>>>\n    ) => Effect.Effect<void, never, R>,\n    readonly target?: unknown\n  ) {\n  }\n  [Hash.symbol](): number {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return this.target ?\n      isRequestResolver(that) && Equal.equals(this.target, (that as RequestResolverImpl<any, any>).target) :\n      this === that\n  }\n  identified(...ids: Array<unknown>): RequestResolver.RequestResolver<A, R> {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isRequestResolver = (u: unknown): u is RequestResolver.RequestResolver<unknown, unknown> =>\n  hasProperty(u, RequestResolverTypeId)\n\n// end\n\n/** @internal */\nexport const resolverLocally = dual<\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => <R, B extends Request.Request<any, any>>(\n    use: RequestResolver.RequestResolver<B, R>\n  ) => RequestResolver.RequestResolver<B, R>,\n  <R, B extends Request.Request<any, any>, A>(\n    use: RequestResolver.RequestResolver<B, R>,\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => RequestResolver.RequestResolver<B, R>\n>(3, <R, B extends Request.Request<any, any>, A>(\n  use: RequestResolver.RequestResolver<B, R>,\n  self: FiberRef.FiberRef<A>,\n  value: A\n): RequestResolver.RequestResolver<B, R> =>\n  new RequestResolverImpl<B, R>(\n    (requests) =>\n      fiberRefLocally(\n        use.runAll(requests),\n        self,\n        value\n      ),\n    Chunk.make(\"Locally\", use, self, value)\n  ))\n\n/** @internal */\nexport const requestBlockLocally = <A>(\n  self: BlockedRequests.RequestBlock,\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock => _blockedRequests.reduce(self, LocallyReducer(ref, value))\n\nconst LocallyReducer = <A>(\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock.Reducer<BlockedRequests.RequestBlock> => ({\n  emptyCase: () => _blockedRequests.empty,\n  parCase: (left, right) => _blockedRequests.par(left, right),\n  seqCase: (left, right) => _blockedRequests.seq(left, right),\n  singleCase: (dataSource, blockedRequest) =>\n    _blockedRequests.single(\n      resolverLocally(dataSource, ref, value),\n      blockedRequest as any\n    )\n})\n\n/* @internal */\nexport const fiberRefLocally: {\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R>\n} = dual(\n  3,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R> =>\n    acquireUseRelease(\n      zipLeft(fiberRefGet(self), fiberRefSet(self, value)),\n      () => use,\n      (oldValue) => fiberRefSet(self, oldValue)\n    )\n)\n\n/* @internal */\nexport const fiberRefLocallyWith = dual<\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<B, E, R>\n>(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))))\n\n/** @internal */\nexport const fiberRefUnsafeMake = <Value>(\n  initial: Value,\n  options?: {\n    readonly fork?: ((a: Value) => Value) | undefined\n    readonly join?: ((left: Value, right: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: internalDiffer.update(),\n    fork: options?.fork ?? identity,\n    join: options?.join\n  })\n\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = <A>(\n  initial: HashSet.HashSet<A>\n): FiberRef.FiberRef<HashSet.HashSet<A>> => {\n  const differ = internalDiffer.hashSet<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = <A>(\n  initial: ReadonlyArray<A>\n): FiberRef.FiberRef<ReadonlyArray<A>> => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update<A>())\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeContext = <A>(\n  initial: Context.Context<A>\n): FiberRef.FiberRef<Context.Context<A>> => {\n  const differ = internalDiffer.environment<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakePatch = <Value, Patch>(\n  initial: Value,\n  options: {\n    readonly differ: Differ.Differ<Value, Patch>\n    readonly fork: Patch\n    readonly join?: ((oldV: Value, newV: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this)\n    },\n    diff: (oldValue: Value, newValue: Value) => options.differ.diff(oldValue, newValue),\n    combine: (first: Patch, second: Patch) => options.differ.combine(first, second),\n    patch: (patch: Patch) => (oldValue: Value) => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  }\n  return _fiberRef\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: _runtimeFlags.differ,\n    fork: _runtimeFlags.differ.empty\n  })\n\n/** @internal */\nexport const currentContext: FiberRef.FiberRef<Context.Context<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentContext\"),\n  () => fiberRefUnsafeMakeContext(Context.empty())\n)\n\n/** @internal */\nexport const currentSchedulingPriority: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"),\n  () => fiberRefUnsafeMake(0)\n)\n\n/** @internal */\nexport const currentMaxOpsBeforeYield: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"),\n  () => fiberRefUnsafeMake(2048)\n)\n\n/** @internal */\nexport const currentLogAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogAnnotation\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogLevel\"),\n  () => fiberRefUnsafeMake<LogLevel.LogLevel>(logLevelInfo)\n)\n\n/** @internal */\nexport const currentLogSpan: FiberRef.FiberRef<List.List<LogSpan.LogSpan>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogSpan\"),\n  () => fiberRefUnsafeMake(List.empty<LogSpan.LogSpan>())\n)\n\n/** @internal */\nexport const withSchedulingPriority = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler))\n\n/** @internal */\nexport const withMaxOpsBeforeYield = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler))\n\n/** @internal */\nexport const currentConcurrency: FiberRef.FiberRef<\"unbounded\" | number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentConcurrency\"),\n  () => fiberRefUnsafeMake<\"unbounded\" | number>(\"unbounded\")\n)\n\n/**\n * @internal\n */\nexport const currentRequestBatching = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestBatching\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentUnhandledErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelDebug))\n)\n\n/** @internal */\nexport const withUnhandledErrorLogLevel = dual<\n  (level: Option.Option<LogLevel.LogLevel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>) => Effect.Effect<A, E, R>\n>(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level))\n\n/** @internal */\nexport const currentMetricLabels: FiberRef.FiberRef<ReadonlyArray<MetricLabel.MetricLabel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMetricLabels\"),\n  () => fiberRefUnsafeMakeReadonlyArray(Arr.empty())\n)\n\n/* @internal */\nexport const metricLabels: Effect.Effect<ReadonlyArray<MetricLabel.MetricLabel>> = fiberRefGet(\n  currentMetricLabels\n)\n\n/** @internal */\nexport const currentForkScopeOverride: FiberRef.FiberRef<Option.Option<fiberScope.FiberScope>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"),\n  () =>\n    fiberRefUnsafeMake(Option.none(), {\n      fork: () => Option.none() as Option.Option<fiberScope.FiberScope>,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentInterruptedCause: FiberRef.FiberRef<Cause.Cause<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentInterruptedCause\"),\n  () =>\n    fiberRefUnsafeMake(internalCause.empty, {\n      fork: () => internalCause.empty,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentTracerEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerEnabled\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerTimingEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerTiming\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerSpanAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentTracerSpanLinks: FiberRef.FiberRef<Chunk.Chunk<Tracer.SpanLink>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"),\n  () => fiberRefUnsafeMake(Chunk.empty())\n)\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const ScopeTypeId: Scope.ScopeTypeId = Symbol.for(\"effect/Scope\") as Scope.ScopeTypeId\n\n/** @internal */\nexport const CloseableScopeTypeId: Scope.CloseableScopeTypeId = Symbol.for(\n  \"effect/CloseableScope\"\n) as Scope.CloseableScopeTypeId\n\n/* @internal */\nexport const scopeAddFinalizer = (\n  self: Scope.Scope,\n  finalizer: Effect.Effect<unknown>\n): Effect.Effect<void> => self.addFinalizer(() => asVoid(finalizer))\n\n/* @internal */\nexport const scopeAddFinalizerExit = (\n  self: Scope.Scope,\n  finalizer: Scope.Scope.Finalizer\n): Effect.Effect<void> => self.addFinalizer(finalizer)\n\n/* @internal */\nexport const scopeClose = (\n  self: Scope.Scope.Closeable,\n  exit: Exit.Exit<unknown, unknown>\n): Effect.Effect<void> => self.close(exit)\n\n/* @internal */\nexport const scopeFork = (\n  self: Scope.Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n): Effect.Effect<Scope.Scope.Closeable> => self.fork(strategy)\n\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const causeSquash = <E>(self: Cause.Cause<E>): unknown => {\n  return causeSquashWith(identity)(self)\n}\n\n/** @internal */\nexport const causeSquashWith = dual<\n  <E>(f: (error: E) => unknown) => (self: Cause.Cause<E>) => unknown,\n  <E>(self: Cause.Cause<E>, f: (error: E) => unknown) => unknown\n>(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f))\n  switch (option._tag) {\n    case \"None\": {\n      return pipe(\n        internalCause.defects(self),\n        Chunk.head,\n        Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap((fiberId) =>\n              Arr.fromIterable(FiberId.ids(fiberId)).map((id) => `#${id}`)\n            )\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0)\n          },\n          onSome: identity\n        })\n      )\n    }\n    case \"Some\": {\n      return option.value\n    }\n  }\n})\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const YieldableError: new(message?: string, options?: ErrorOptions) => Cause.YieldableError = (function() {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this)\n    }\n    toJSON() {\n      return { ...this }\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString()\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), { renderErrorCause: true })\n      }\n      return this\n    }\n  }\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype)\n  return YieldableError as any\n})()\n\nconst makeException = <T extends { _tag: string; message?: string }>(\n  proto: Omit<T, keyof Cause.YieldableError | \"_tag\">,\n  tag: T[\"_tag\"]\n): new(message?: string | undefined) => T => {\n  class Base extends YieldableError {\n    readonly _tag = tag\n  }\n  Object.assign(Base.prototype, proto)\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/** @internal */\nexport const RuntimeExceptionTypeId: Cause.RuntimeExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/RuntimeException\"\n) as Cause.RuntimeExceptionTypeId\n\n/** @internal */\nexport const RuntimeException = makeException<Cause.RuntimeException>({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\")\n\n/** @internal */\nexport const isRuntimeException = (u: unknown): u is Cause.RuntimeException => hasProperty(u, RuntimeExceptionTypeId)\n\n/** @internal */\nexport const InterruptedExceptionTypeId: Cause.InterruptedExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InterruptedException\"\n) as Cause.InterruptedExceptionTypeId\n\n/** @internal */\nexport const InterruptedException = makeException<Cause.InterruptedException>({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\")\n\n/** @internal */\nexport const isInterruptedException = (u: unknown): u is Cause.InterruptedException =>\n  hasProperty(u, InterruptedExceptionTypeId)\n\n/** @internal */\nexport const IllegalArgumentExceptionTypeId: Cause.IllegalArgumentExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/IllegalArgument\"\n) as Cause.IllegalArgumentExceptionTypeId\n\n/** @internal */\nexport const IllegalArgumentException = makeException<Cause.IllegalArgumentException>({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\")\n\n/** @internal */\nexport const isIllegalArgumentException = (u: unknown): u is Cause.IllegalArgumentException =>\n  hasProperty(u, IllegalArgumentExceptionTypeId)\n\n/** @internal */\nexport const NoSuchElementExceptionTypeId: Cause.NoSuchElementExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/NoSuchElement\"\n) as Cause.NoSuchElementExceptionTypeId\n\n/** @internal */\nexport const NoSuchElementException = makeException<Cause.NoSuchElementException>({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\")\n\n/** @internal */\nexport const isNoSuchElementException = (u: unknown): u is Cause.NoSuchElementException =>\n  hasProperty(u, NoSuchElementExceptionTypeId)\n\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId: Cause.InvalidPubSubCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InvalidPubSubCapacityException\"\n) as Cause.InvalidPubSubCapacityExceptionTypeId\n\n/** @internal */\nexport const InvalidPubSubCapacityException = makeException<Cause.InvalidPubSubCapacityException>({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\")\n\n/** @internal */\nexport const ExceededCapacityExceptionTypeId: Cause.ExceededCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/ExceededCapacityException\"\n) as Cause.ExceededCapacityExceptionTypeId\n\n/** @internal */\nexport const ExceededCapacityException = makeException<Cause.ExceededCapacityException>({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\")\n\n/** @internal */\nexport const isExceededCapacityException = (u: unknown): u is Cause.ExceededCapacityException =>\n  hasProperty(u, ExceededCapacityExceptionTypeId)\n\n/** @internal */\nexport const isInvalidCapacityError = (u: unknown): u is Cause.InvalidPubSubCapacityException =>\n  hasProperty(u, InvalidPubSubCapacityExceptionTypeId)\n\n/** @internal */\nexport const TimeoutExceptionTypeId: Cause.TimeoutExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/Timeout\"\n) as Cause.TimeoutExceptionTypeId\n\n/** @internal */\nexport const TimeoutException = makeException<Cause.TimeoutException>({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\")\n/** @internal */\nexport const timeoutExceptionFromDuration = (duration: Duration.DurationInput): Cause.TimeoutException =>\n  new TimeoutException(`Operation timed out before the specified duration of '${Duration.format(duration)}' elapsed`)\n\n/** @internal */\nexport const isTimeoutException = (u: unknown): u is Cause.TimeoutException => hasProperty(u, TimeoutExceptionTypeId)\n\n/** @internal */\nexport const UnknownExceptionTypeId: Cause.UnknownExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/UnknownException\"\n) as Cause.UnknownExceptionTypeId\n\n/** @internal */\nexport const UnknownException: new(cause: unknown, message?: string | undefined) => Cause.UnknownException =\n  (function() {\n    class UnknownException extends YieldableError {\n      readonly _tag = \"UnknownException\"\n      readonly error: unknown\n      constructor(readonly cause: unknown, message?: string) {\n        super(message ?? \"An unknown error occurred\", { cause })\n        this.error = cause\n      }\n    }\n    Object.assign(UnknownException.prototype, {\n      [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n      name: \"UnknownException\"\n    })\n    return UnknownException as any\n  })()\n\n/** @internal */\nexport const isUnknownException = (u: unknown): u is Cause.UnknownException => hasProperty(u, UnknownExceptionTypeId)\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const exitIsExit = (u: unknown): u is Exit.Exit<unknown, unknown> =>\n  isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\")\n\n/** @internal */\nexport const exitIsFailure = <A, E>(self: Exit.Exit<A, E>): self is Exit.Failure<A, E> => self._tag === \"Failure\"\n\n/** @internal */\nexport const exitIsSuccess = <A, E>(self: Exit.Exit<A, E>): self is Exit.Success<A, E> => self._tag === \"Success\"\n\n/** @internal */\nexport const exitIsInterrupted = <A, E>(self: Exit.Exit<A, E>): boolean => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return false\n  }\n}\n\n/** @internal */\nexport const exitAs = dual<\n  <A2>(value: A2) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E>,\n  <A, E, A2>(self: Exit.Exit<A, E>, value: A2) => Exit.Exit<A2, E>\n>(2, <A, E, A2>(self: Exit.Exit<A, E>, value: A2): Exit.Exit<A2, E> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exitSucceed(value) as Exit.Exit<A2, E>\n    }\n  }\n})\n\n/** @internal */\nexport const exitAsVoid = <A, E>(self: Exit.Exit<A, E>): Exit.Exit<void, E> => exitAs(self, void 0)\n\n/** @internal */\nexport const exitCauseOption = <A, E>(self: Exit.Exit<A, E>): Option.Option<Cause.Cause<E>> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return Option.none()\n  }\n}\n\n/** @internal */\nexport const exitCollectAll = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  options?: {\n    readonly parallel?: boolean | undefined\n  }\n): Option.Option<Exit.Exit<Array<A>, E>> =>\n  exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential)\n\n/** @internal */\nexport const exitDie = (defect: unknown): Exit.Exit<never> =>\n  exitFailCause(internalCause.die(defect)) as Exit.Exit<never>\n\n/** @internal */\nexport const exitExists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit.Exit<A, E>) => self is Exit.Exit<B>\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit.Exit<A, E>) => boolean\n  <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B>\n  <A, E>(self: Exit.Exit<A, E>, predicate: Predicate<A>): boolean\n} = dual(2, <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitFail = <E>(error: E): Exit.Exit<never, E> =>\n  exitFailCause(internalCause.fail(error)) as Exit.Exit<never, E>\n\n/** @internal */\nexport const exitFailCause = <E>(cause: Cause.Cause<E>): Exit.Exit<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/** @internal */\nexport const exitFlatMap = dual<\n  <A, A2, E2>(f: (a: A) => Exit.Exit<A2, E2>) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>): Exit.Exit<A2, E | E2> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatMapEffect: {\n  <A, E, A2, E2, R>(\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): (self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  <A, E, A2, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): Effect.Effect<Exit.Exit<A2, E>, E2, R>\n} = dual(2, <A, E, A2, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n): Effect.Effect<Exit.Exit<A2, E>, E2, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatten = <A, E, E2>(\n  self: Exit.Exit<Exit.Exit<A, E>, E2>\n): Exit.Exit<A, E | E2> => pipe(self, exitFlatMap(identity))\n\n/** @internal */\nexport const exitForEachEffect: {\n  <A, B, E2, R>(\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): <E>(self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n  <A, E, B, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n} = dual(2, <A, E, B, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<B, E2, R>\n): Effect.Effect<Exit.Exit<B, E | E2>, never, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exit(f(self.effect_instruction_i0))\n    }\n  }\n})\n\n/** @internal */\nexport const exitFromEither = <R, L>(either: Either.Either<R, L>): Exit.Exit<R, L> => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left)\n    case \"Right\":\n      return exitSucceed(either.right)\n  }\n}\n\n/** @internal */\nexport const exitFromOption = <A>(option: Option.Option<A>): Exit.Exit<A, void> => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0)\n    case \"Some\":\n      return exitSucceed(option.value)\n  }\n}\n\n/** @internal */\nexport const exitGetOrElse = dual<\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2) => <A>(self: Exit.Exit<A, E>) => A | A2,\n  <A, E, A2>(self: Exit.Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2) => A | A2\n>(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0\n  }\n})\n\n/** @internal */\nexport const exitInterrupt = (fiberId: FiberId.FiberId): Exit.Exit<never> =>\n  exitFailCause(internalCause.interrupt(fiberId))\n\n/** @internal */\nexport const exitMap = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<B, E>,\n  <A, E, B>(self: Exit.Exit<A, E>, f: (a: A) => B) => Exit.Exit<B, E>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapBoth = dual<\n  <E, A, E2, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<A2, E2>,\n  <A, E, E2, A2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Exit.Exit<A2, E2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapError = dual<\n  <E, E2>(f: (e: E) => E2) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <A, E, E2>(self: Exit.Exit<A, E>, f: (e: E) => E2) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMapErrorCause = dual<\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <E, A, E2>(self: Exit.Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatch = dual<\n  <E, A, Z1, Z2>(options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => (self: Exit.Exit<A, E>) => Z1 | Z2,\n  <A, E, Z1, Z2>(self: Exit.Exit<A, E>, options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => Z1 | Z2\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatchEffect = dual<\n  <E, A2, E2, R, A, A3, E3, R2>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>,\n  <A, E, A2, E2, R, A3, E3, R2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitSucceed = <A>(value: A): Exit.Exit<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/** @internal */\nexport const exitVoid: Exit.Exit<void> = exitSucceed(void 0)\n\n/** @internal */\nexport const exitZip = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipPar = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipWith = dual<\n  <B, E2, A, C, E>(\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Exit.Exit<A, E>,\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => Exit.Exit<C, E | E2>\n>(3, (\n  self,\n  that,\n  { onFailure, onSuccess }\n) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitFailCause(self.effect_instruction_i0)\n        case OpCodes.OP_FAILURE: {\n          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0))\n        }\n      }\n    }\n    case OpCodes.OP_SUCCESS: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0))\n        case OpCodes.OP_FAILURE:\n          return exitFailCause(that.effect_instruction_i0)\n      }\n    }\n  }\n})\n\nconst exitCollectAllInternal = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  combineCauses: (causeA: Cause.Cause<E>, causeB: Cause.Cause<E>) => Cause.Cause<E>\n): Option.Option<Exit.Exit<Array<A>, E>> => {\n  const list = Chunk.fromIterable(exits)\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none()\n  }\n  return pipe(\n    Chunk.tailNonEmpty(list),\n    Arr.reduce(\n      pipe(Chunk.headNonEmpty(list), exitMap<A, Chunk.Chunk<A>>(Chunk.of)),\n      (accumulator, current) =>\n        pipe(\n          accumulator,\n          exitZipWith(current, {\n            onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n            onFailure: combineCauses\n          })\n        )\n    ),\n    exitMap(Chunk.reverse),\n    exitMap((chunk) => Chunk.toReadonlyArray(chunk) as Array<A>),\n    Option.some\n  )\n}\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const deferredUnsafeMake = <A, E = never>(fiberId: FiberId.FiberId): Deferred.Deferred<A, E> => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending<A, E>([])),\n    commit() {\n      return deferredAwait(this)\n    },\n    blockingOn: fiberId\n  }\n  return _deferred\n}\n\n/* @internal */\nexport const deferredMake = <A, E = never>(): Effect.Effect<Deferred.Deferred<A, E>> =>\n  flatMap(fiberId, (id) => deferredMakeAs<A, E>(id))\n\n/* @internal */\nexport const deferredMakeAs = <A, E = never>(fiberId: FiberId.FiberId): Effect.Effect<Deferred.Deferred<A, E>> =>\n  sync(() => deferredUnsafeMake<A, E>(fiberId))\n\n/* @internal */\nexport const deferredAwait = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<A, E> =>\n  asyncInterrupt<A, E>((resume) => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return resume(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume)\n        return deferredInterruptJoiner(self, resume)\n      }\n    }\n  }, self.blockingOn)\n\n/* @internal */\nexport const deferredComplete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = dual(\n  2,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean> =>\n    intoDeferred(effect, self)\n)\n\n/* @internal */\nexport const deferredCompleteWith = dual<\n  <A, E>(effect: Effect.Effect<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>) => Effect.Effect<boolean>\n>(2, (self, effect) =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return false\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        MutableRef.set(self.state, deferred.done(effect))\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect)\n        }\n        return true\n      }\n    }\n  }))\n\n/* @internal */\nexport const deferredDone = dual<\n  <A, E>(exit: Exit.Exit<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, exit: Exit.Exit<A, E>) => Effect.Effect<boolean>\n>(2, (self, exit) => deferredCompleteWith(self, exit))\n\n/* @internal */\nexport const deferredFail = dual<\n  <E>(error: E) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, error: E) => Effect.Effect<boolean>\n>(2, (self, error) => deferredCompleteWith(self, fail(error)))\n\n/* @internal */\nexport const deferredFailSync = dual<\n  <E>(evaluate: LazyArg<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<E>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)))\n\n/* @internal */\nexport const deferredFailCause = dual<\n  <E>(cause: Cause.Cause<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, cause: Cause.Cause<E>) => Effect.Effect<boolean>\n>(2, (self, cause) => deferredCompleteWith(self, failCause(cause)))\n\n/* @internal */\nexport const deferredFailCauseSync = dual<\n  <E>(evaluate: LazyArg<Cause.Cause<E>>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)))\n\n/* @internal */\nexport const deferredDie = dual<\n  (defect: unknown) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, defect: unknown) => Effect.Effect<boolean>\n>(2, (self, defect) => deferredCompleteWith(self, die(defect)))\n\n/* @internal */\nexport const deferredDieSync = dual<\n  (evaluate: LazyArg<unknown>) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<unknown>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)))\n\n/* @internal */\nexport const deferredInterrupt = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  flatMap(fiberId, (fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredInterruptWith = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<boolean>\n>(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredIsDone = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE)\n\n/* @internal */\nexport const deferredPoll = <A, E>(\n  self: Deferred.Deferred<A, E>\n): Effect.Effect<Option.Option<Effect.Effect<A, E>>> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return Option.some(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        return Option.none()\n      }\n    }\n  })\n\n/* @internal */\nexport const deferredSucceed = dual<\n  <A>(value: A) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, value: A) => Effect.Effect<boolean>\n>(2, (self, value) => deferredCompleteWith(self, succeed(value)))\n\n/* @internal */\nexport const deferredSync = dual<\n  <A>(evaluate: LazyArg<A>) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<A>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)))\n\n/** @internal */\nexport const deferredUnsafeDone = <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): void => {\n  const state = MutableRef.get(self.state)\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect))\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect)\n    }\n  }\n}\n\nconst deferredInterruptJoiner = <A, E>(\n  self: Deferred.Deferred<A, E>,\n  joiner: (effect: Effect.Effect<A, E>) => void\n): Effect.Effect<void> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n      const index = state.joiners.indexOf(joiner)\n      if (index >= 0) {\n        // we can splice here as the internal state is mutable\n        state.joiners.splice(index, 1)\n      }\n    }\n  })\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext))\n\n/* @internal */\nexport const context = <R>(): Effect.Effect<Context.Context<R>, never, R> => constContext as any\n\n/* @internal */\nexport const contextWith = <R0, A>(\n  f: (context: Context.Context<R0>) => A\n): Effect.Effect<A, never, R0> => map(context<R0>(), f)\n\n/* @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | R0> => flatMap(context<R0>(), f)\n\n/* @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) => Effect.Effect<A, E>\n>(2, <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) =>\n  fiberRefLocally(\n    currentContext,\n    context\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const provideSomeContext = dual<\n  <R>(context: Context.Context<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) =>\n  fiberRefLocallyWith(\n    currentContext,\n    (parent) => Context.merge(parent, context)\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R0>,\n  <A, E, R, R0>(\n    self: Effect.Effect<A, E, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => Effect.Effect<A, E, R0>\n>(2, <A, E, R, R0>(\n  self: Effect.Effect<A, E, R>,\n  f: (context: Context.Context<R0>) => Context.Context<R>\n) => contextWithEffect((context: Context.Context<R0>) => provideContext(self, f(context))))\n\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const currentSpanFromFiber = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Option.Option<Tracer.Span> => {\n  const span = fiber.currentSpan\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none()\n}\n\nconst NoopSpanProto: Tracer.Span = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  name: \"noop\",\n  sampled: false,\n  parent: Option.none(),\n  context: Context.empty(),\n  status: {\n    _tag: \"Ended\",\n    startTime: BigInt(0),\n    endTime: BigInt(0),\n    exit: exitVoid\n  },\n  attributes: new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {}\n}\n\n/** @internal */\nexport const noopSpan = (name: string): Tracer.Span => {\n  const span = Object.create(NoopSpanProto)\n  span.name = name\n  return span\n}\n"],"names":["internalCall","Arr","Chunk","Context","Duration","Either","Equal","FiberId","dual","identity","pipe","globalValue","Hash","HashMap","format","NodeInspectSymbol","toJSON","List","MutableRef","Option","pipeArguments","hasProperty","isObject","isPromiseLike","RuntimeFlagsPatch","YieldWrap","_blockedRequests","internalCause","deferred","internalDiffer","CommitPrototype","effectVariance","StructuralCommitPrototype","getBugErrorMessage","DeferredOpCodes","OpCodes","_runtimeFlags","SingleShotGen","EffectErrorSymbolKey","EffectErrorTypeId","Symbol","for","isEffectError","u","makeEffectError","cause","_tag","blocked","blockedRequests","_continue","effect","EffectPrimitive","effect_instruction_i0","effect_instruction_i1","runRequestBlock","EffectTypeId","RevertFlags","patch","op","_op","OP_REVERT_FLAGS","constructor","undefined","effect_instruction_i2","trace","symbol","that","cached","random","arguments","_id","toString","iterator","EffectPrimitiveFailure","exitIsExit","equals","string","combine","hash","EffectPrimitiveSuccess","value","isEffect","withFiberRuntime","withRuntime","OP_WITH_RUNTIME","acquireUseRelease","acquire","use","release","uninterruptibleMask","restore","flatMap","a","exit","suspend","matchCauseEffect","onFailure","OP_FAILURE","failCause","sequential","OP_SUCCESS","onSuccess","as","self","succeed","asVoid","custom","wrapper","OP_COMMIT","length","commit","Error","unsafeAsync","register","blockingOn","none","OP_ASYNC","cancelerRef","resume","onInterrupt","_","void_","asyncInterrupt","async_","backingResume","pendingEffect","proxyResume","controllerRef","AbortController","signal","abort","async","catchAllCause","f","OP_ON_FAILURE","catchAll","matchEffect","catchIf","predicate","either","failureOrCause","left","right","catchSome","pf","getOrElse","checkInterruptible","status","interruption","runtimeFlags","spanSymbol","originalSymbol","originalInstance","obj","capture","span","isSome","Proxy","has","target","p","get","die","defect","fiber","currentSpanFromFiber","dieMessage","message","failCauseSync","RuntimeException","dieSync","evaluate","sync","e","matchCause","exitFailCause","exitSucceed","fail","error","failSync","fiberId","state","id","fiberIdWith","OP_ON_SUCCESS","andThen","b","then","UnknownException","step","flatten","flip","options","OP_ON_SUCCESS_AND_FAILURE","defects","electFailures","failures","unsafeHead","forEachSequential","arr","fromIterable","ret","allocate","i","whileLoop","while","body","forEachSequentialDiscard","if_","args","onTrue","onFalse","interrupt","interruptWith","interruptible","OP_UPDATE_RUNTIME_FLAGS","enable","Interruption","interruptibleMask","oldFlags","uninterruptible","intoDeferred","deferredDone","map","mapBoth","mapError","onError","cleanup","onExit","exitIsSuccess","cause1","result","cause2","success","zipRight","exitMatch","isInterruptedOnly","interruptors","orElse","attemptOrElse","orDie","orDieWith","partitionMap","thunk","OP_SYNC","tap","transplant","scopeOverride","getFiberRef","currentForkScopeOverride","scope","fiberRefLocally","some","getOrThrow","keepDefectsAndElectFailures","disable","void","updateRuntimeFlags","whenEffect","condition","OP_WHILE","gen","bind","OP_ITERATOR","withConcurrency","concurrency","currentConcurrency","withRequestBatching","requestBatching","currentRequestBatching","withRuntimeFlags","update","withTracerEnabled","enabled","currentTracerEnabled","withTracerTiming","currentTracerTimingEnabled","yieldNow","OP_YIELD","priority","withSchedulingPriority","zip","zipFlatten","zipLeft","zipWith","never","interval","setInterval","clearInterval","interruptFiber","interruptAsFiber","interruptAsFork","await","logLevelAll","syslog","label","ordinal","Number","MIN_SAFE_INTEGER","logLevelFatal","logLevelError","logLevelWarning","logLevelInfo","logLevelDebug","logLevelTrace","logLevelNone","MAX_SAFE_INTEGER","allLogLevels","FiberRefSymbolKey","FiberRefTypeId","fiberRefVariance","_A","fiberRefGet","fiberRefGetAndSet","fiberRefModify","v","fiberRefGetAndUpdate","fiberRefGetAndUpdateSome","fiberRefGetWith","fiberRefSet","fiberRefDelete","unsafeDeleteFiberRef","fiberRefReset","initial","setFiberRef","fiberRefModifySome","def","fiberRefUpdate","fiberRefUpdateSome","fiberRefUpdateAndGet","fiberRefUpdateSomeAndGet","RequestResolverSymbolKey","RequestResolverTypeId","requestResolverVariance","_R","RequestResolverImpl","runAll","isRequestResolver","identified","ids","resolverLocally","requests","make","requestBlockLocally","ref","reduce","LocallyReducer","emptyCase","empty","parCase","par","seqCase","seq","singleCase","dataSource","blockedRequest","single","oldValue","fiberRefLocallyWith","fiberRefUnsafeMake","fiberRefUnsafeMakePatch","differ","fork","join","fiberRefUnsafeMakeHashSet","hashSet","fiberRefUnsafeMakeReadonlyArray","readonlyArray","fiberRefUnsafeMakeContext","environment","_fiberRef","diff","newValue","first","second","n","fiberRefUnsafeMakeRuntimeFlags","currentContext","currentSchedulingPriority","currentMaxOpsBeforeYield","currentLogAnnotations","currentLogLevel","currentLogSpan","scheduler","withMaxOpsBeforeYield","currentUnhandledErrorLogLevel","withUnhandledErrorLogLevel","level","currentMetricLabels","metricLabels","parent","currentInterruptedCause","currentTracerSpanAnnotations","currentTracerSpanLinks","ScopeTypeId","CloseableScopeTypeId","scopeAddFinalizer","finalizer","addFinalizer","scopeAddFinalizerExit","scopeClose","close","scopeFork","strategy","causeSquash","causeSquashWith","option","failureOption","head","match","onNone","interrupts","InterruptedException","onSome","YieldableError","globalThis","prototype","stack","split","slice","pretty","renderErrorCause","Object","assign","makeException","proto","tag","Base","name","RuntimeExceptionTypeId","isRuntimeException","InterruptedExceptionTypeId","isInterruptedException","IllegalArgumentExceptionTypeId","IllegalArgumentException","isIllegalArgumentException","NoSuchElementExceptionTypeId","NoSuchElementException","isNoSuchElementException","InvalidPubSubCapacityExceptionTypeId","InvalidPubSubCapacityException","ExceededCapacityExceptionTypeId","ExceededCapacityException","isExceededCapacityException","isInvalidCapacityError","TimeoutExceptionTypeId","TimeoutException","timeoutExceptionFromDuration","duration","isTimeoutException","UnknownExceptionTypeId","isUnknownException","exitIsFailure","exitIsInterrupted","isInterrupted","exitAs","exitAsVoid","exitCauseOption","exitCollectAll","exits","exitCollectAllInternal","parallel","exitDie","exitExists","refinement","exitFail","exitFlatMap","exitFlatMapEffect","exitFlatten","exitForEachEffect","exitFromEither","exitFromOption","exitGetOrElse","exitInterrupt","exitMap","exitMapBoth","exitMapError","exitMapErrorCause","exitMatchEffect","exitVoid","exitZip","exitZipWith","a2","exitZipLeft","exitZipRight","exitZipPar","exitZipParLeft","exitZipParRight","combineCauses","list","isNonEmpty","tailNonEmpty","headNonEmpty","of","accumulator","current","prepend","reverse","chunk","toReadonlyArray","deferredUnsafeMake","_deferred","DeferredTypeId","deferredVariance","pending","deferredAwait","deferredMake","deferredMakeAs","OP_STATE_DONE","OP_STATE_PENDING","joiners","push","deferredInterruptJoiner","deferredComplete","deferredCompleteWith","set","done","len","deferredFail","deferredFailSync","deferredFailCause","deferredFailCauseSync","deferredDie","deferredDieSync","deferredInterrupt","deferredInterruptWith","deferredIsDone","deferredPoll","deferredSucceed","deferredSync","deferredUnsafeDone","joiner","index","indexOf","splice","constContext","context","contextWith","contextWithEffect","provideContext","provideSomeContext","merge","mapInputContext","currentSpan","NoopSpanProto","spanId","traceId","sampled","startTime","BigInt","endTime","attributes","Map","links","kind","attribute","event","end","noopSpan","create"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1629, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}