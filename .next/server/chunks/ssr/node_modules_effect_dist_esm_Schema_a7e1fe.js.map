{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"Schema.js","sources":["file:///home/yurtur/projects/candle-constructor/node_modules/effect/src/Schema.ts"],"sourcesContent":["/**\n * @since 3.10.0\n */\n\nimport type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from \"./Arbitrary.js\"\nimport * as array_ from \"./Array.js\"\nimport * as bigDecimal_ from \"./BigDecimal.js\"\nimport * as bigInt_ from \"./BigInt.js\"\nimport * as boolean_ from \"./Boolean.js\"\nimport type { Brand } from \"./Brand.js\"\nimport * as cause_ from \"./Cause.js\"\nimport * as chunk_ from \"./Chunk.js\"\nimport * as config_ from \"./Config.js\"\nimport * as configError_ from \"./ConfigError.js\"\nimport * as data_ from \"./Data.js\"\nimport * as dateTime from \"./DateTime.js\"\nimport * as duration_ from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as either_ from \"./Either.js\"\nimport * as Encoding from \"./Encoding.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport * as exit_ from \"./Exit.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as fiberId_ from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as hashMap_ from \"./HashMap.js\"\nimport * as hashSet_ from \"./HashSet.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as filters_ from \"./internal/schema/filters.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as list_ from \"./List.js\"\nimport * as number_ from \"./Number.js\"\nimport * as option_ from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as pretty_ from \"./Pretty.js\"\nimport * as record_ from \"./Record.js\"\nimport * as redacted_ from \"./Redacted.js\"\nimport * as Request from \"./Request.js\"\nimport type { ParseOptions } from \"./SchemaAST.js\"\nimport * as AST from \"./SchemaAST.js\"\nimport * as sortedSet_ from \"./SortedSet.js\"\nimport * as string_ from \"./String.js\"\nimport * as struct_ from \"./Struct.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 3.10.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Schema\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>\n}\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const make = <A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> => (class SchemaClass {\n  [TypeId] = variance\n  static Type: A\n  static Encoded: I\n  static Context: R\n  static [TypeId] = variance\n  static ast = ast\n  static annotations(annotations: Annotations.Schema<A>) {\n    return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static pipe() {\n    return pipeArguments(this, arguments)\n  }\n  static toString() {\n    return String(ast)\n  }\n})\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst builtInAnnotations = {\n  schemaId: AST.SchemaIdAnnotationId,\n  message: AST.MessageAnnotationId,\n  missingMessage: AST.MissingMessageAnnotationId,\n  identifier: AST.IdentifierAnnotationId,\n  title: AST.TitleAnnotationId,\n  description: AST.DescriptionAnnotationId,\n  examples: AST.ExamplesAnnotationId,\n  default: AST.DefaultAnnotationId,\n  documentation: AST.DocumentationAnnotationId,\n  jsonSchema: AST.JSONSchemaAnnotationId,\n  arbitrary: AST.ArbitraryAnnotationId,\n  pretty: AST.PrettyAnnotationId,\n  equivalence: AST.EquivalenceAnnotationId,\n  concurrency: AST.ConcurrencyAnnotationId,\n  batching: AST.BatchingAnnotationId,\n  parseIssueTitle: AST.ParseIssueTitleAnnotationId,\n  parseOptions: AST.ParseOptionsAnnotationId,\n  decodingFallback: AST.DecodingFallbackAnnotationId\n}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = { ...annotations }\n\n  for (const key in builtInAnnotations) {\n    if (key in annotations) {\n      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]\n      out[id] = annotations[key as keyof typeof annotations]\n      delete out[key]\n    }\n  }\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 3.10.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSchema = <S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> => schema as any\n\n/**\n * @category formatting\n * @since 3.10.0\n */\nexport const format = <S extends Schema.All>(schema: S): string => String(schema.ast)\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 3.10.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 3.10.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 3.10.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 3.10.0\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 3.10.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 3.10.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 3.10.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 3.10.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nconst getDefaultLiteralAST = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n) =>\n  AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n\nconst makeLiteralClass = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> => (class LiteralClass extends make<Literals[number]>(ast) {\n  static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n    return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static literals = [...literals] as Literals\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n * import { Either } from \"effect\"\n *\n * const schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 3.10.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {\n  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static enums = { ...enums }\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype AppendType<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer A extends AST.LiteralValue, infer _I, infer _R> ? `${Template}${A}`\n  : never\n\ntype GetTemplateLiteralType<Params> = Params extends [...infer Init, infer Last] ?\n  AppendType<GetTemplateLiteralType<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(\n  ...[head, ...tail]: Params\n): TemplateLiteral<GetTemplateLiteralType<Params>> => {\n  const spans: Array<AST.TemplateLiteralSpan> = []\n  let h = \"\"\n  let ts = tail\n\n  if (isSchema(head)) {\n    if (AST.isLiteral(head.ast)) {\n      h = String(head.ast.literal)\n    } else {\n      ts = [head, ...ts]\n    }\n  } else {\n    h = String(head)\n  }\n\n  for (let i = 0; i < ts.length; i++) {\n    const item = ts[i]\n    if (isSchema(item)) {\n      if (i < ts.length - 1) {\n        const next = ts[i + 1]\n        if (isSchema(next)) {\n          if (AST.isLiteral(next.ast)) {\n            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)))\n            i++\n            continue\n          }\n        } else {\n          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)))\n          i++\n          continue\n        }\n      }\n      spans.push(new AST.TemplateLiteralSpan(item.ast, \"\"))\n    } else {\n      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), \"\"))\n    }\n  }\n\n  if (array_.isNonEmptyArray(spans)) {\n    return make(new AST.TemplateLiteral(h, spans))\n  } else {\n    return make(new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(new AST.Literal(h), \"\")]))\n  }\n}\n\ntype TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue\n\ntype GetTemplateLiteralParserType<Params> = Params extends [infer Head, ...infer Tail] ? readonly [\n    Head extends Schema<infer A, infer _I, infer _R> ? A : Head,\n    ...GetTemplateLiteralParserType<Tail>\n  ]\n  : []\n\ntype AppendEncoded<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer _A, infer I extends AST.LiteralValue, infer _R> ? `${Template}${I}`\n  : never\n\ntype GetTemplateLiteralParserEncoded<Params> = Params extends [...infer Init, infer Last] ?\n  AppendEncoded<GetTemplateLiteralParserEncoded<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}\n\nconst literalValueCoercions: Record<string, ((v: AST.LiteralValue) => AST.LiteralValue)> = {\n  bigint: (v: AST.LiteralValue) => Predicate.isString(v) ? BigInt(v) : v,\n  boolean: (v: AST.LiteralValue) => v === \"true\" ? true : v === \"false\" ? false : v,\n  null: (v: AST.LiteralValue) => v === \"null\" ? null : v\n}\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(\n  ...params: Params\n): TemplateLiteralParser<Params> => {\n  const encodedSchemas: Array<Schema.Any> = []\n  const typeSchemas: Array<Schema.Any> = []\n  const coercions: Record<number, ((v: AST.LiteralValue) => AST.LiteralValue) | undefined> = {}\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i]\n    if (isSchema(param)) {\n      const encoded = encodedSchema(param)\n      if (AST.isNumberKeyword(encoded.ast)) {\n        coercions[i] = Number\n      }\n      encodedSchemas.push(encoded)\n      typeSchemas.push(param)\n    } else {\n      const schema = Literal(param)\n      if (Predicate.isNumber(param)) {\n        coercions[i] = Number\n      } else if (Predicate.isBigInt(param)) {\n        coercions[i] = literalValueCoercions.bigint\n      } else if (Predicate.isBoolean(param)) {\n        coercions[i] = literalValueCoercions.boolean\n      } else if (Predicate.isNull(param)) {\n        coercions[i] = literalValueCoercions.null\n      }\n      encodedSchemas.push(schema)\n      typeSchemas.push(schema)\n    }\n  }\n  const from = TemplateLiteral(...encodedSchemas as any)\n  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)\n  return class TemplateLiteralParserClass extends transformOrFail(from, Tuple(...typeSchemas), {\n    strict: false,\n    decode: (s, _, ast) => {\n      const match = re.exec(s)\n      if (match) {\n        const out: Array<AST.LiteralValue> = match.slice(1, params.length + 1)\n        for (let i = 0; i < out.length; i++) {\n          const coerce = coercions[i]\n          if (coerce) {\n            out[i] = coerce(out[i])\n          }\n        }\n        return ParseResult.succeed(out)\n      }\n      return ParseResult.fail(new ParseResult.Type(ast, s, `${re.source}: no match for ${JSON.stringify(s)}`))\n    },\n    encode: (tuple) => ParseResult.succeed(tuple.join(\"\"))\n  }) {\n    static params = params.slice()\n  } as any\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  make(\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const declare: {\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): SchemaClass<A>\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <const P extends ReadonlyArray<Schema.All>, I, A>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): SchemaClass<A, I, Schema.Context<P[number]>>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BrandSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Brand\")\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> =>\n  makeBrandClass<Schema<A & C, I, R>, string | symbol>(\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({\n        schemaId: BrandSchemaId,\n        [BrandSchemaId]: { constructor },\n        ...annotations\n      })\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const InstanceOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface instanceOf<A> extends AnnotableClass<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      schemaId: InstanceOfSchemaId,\n      [InstanceOfSchemaId]: { constructor },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>\n}\n\nconst getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>\n  AST.Union.make(members.map((m) => m.ast))\n\nconst makeUnionClass = <Members extends AST.Members<Schema.All>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<\n  Members\n> => (class UnionClass\n  extends make<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n    return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static members = [...members]\n})\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport function Union<Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.All>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n) {\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0]\n    : Never\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Element {\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 3.10.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 3.10.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 3.10.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nconst makeTupleTypeClass = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) => (class TupleTypeClass extends make<\n  TupleType.Type<Elements, Rest>,\n  TupleType.Encoded<Elements, Rest>,\n  Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n>(ast) {\n  static override annotations(\n    annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n  ): TupleType<Elements, Rest> {\n    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static elements = [...elements] as any as Elements\n\n  static rest = [...rest] as any as Rest\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nconst makeArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): Array$<Value> => (class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n    return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 3.10.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>\n}\n\nconst makeNonEmptyArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): NonEmptyArray<\n  Value\n> => (class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n    return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    ArrayEnsure<Value>,\n    ReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const ArrayEnsure = <Value extends Schema.Any>(value: Value): ArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class ArrayEnsureClass extends transform(Union(value_, Array$(value_)), Array$(typeSchema(value_)), {\n    strict: true,\n    decode: array_.ensure,\n    encode: (arr) => arr.length === 1 ? arr[0] : arr\n  }) {}\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArrayEnsure<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArrayEnsure = <Value extends Schema.Any>(value: Value): NonEmptyArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class NonEmptyArrayEnsureClass\n    extends transform(Union(value_, NonEmptyArray(value_)), NonEmptyArray(typeSchema(value_)), {\n      strict: true,\n      decode: array_.ensure as any,\n      encode: (arr) => arr.length === 1 ? arr[0] : arr\n    })\n  {}\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        new FromPropertySignature(\n          ast.from.type,\n          ast.from.isOptional,\n          ast.from.isReadonly,\n          ast.from.annotations\n        ),\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"effect/PropertySignature\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @since 3.10.0\n * @category guards\n */\nexport const isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withConstructorDefault: {\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDecodingDefault: {\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast,\n          new ToPropertySignature(AST.typeAST(ast.type), false, true, {}, undefined),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDefaults: {\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Type>\n    }\n  ): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Type>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Type>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const fromKey: {\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 3.10.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            self,\n            typeSchema(self),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          self,\n          OptionFromSelf(typeSchema(self)),\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(self),\n          typeSchema(self),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(self),\n          UndefinedOr(typeSchema(self)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optional = <S extends Schema.All>(self: S): optional<S> => {\n  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword\n    ? AST.undefinedKeyword\n    : UndefinedOr(self).ast\n  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalWith: {\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    options: Options\n  ): (self: S) => optionalWith<S, Options>\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    self: S,\n    options: Options\n  ): optionalWith<S, Options>\n} = dual((args) => isSchema(args[0]), (self, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)\n})\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Struct {\n  /**\n   * @since 3.10.0\n   */\n  export type Fields = {\n    readonly [x: PropertyKey]:\n      | Schema.All\n      | PropertySignature.All\n  }\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  type EncodedTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown> ? K\n      : never\n  }[keyof Fields]\n\n  type TypeTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never\n  }[keyof Fields]\n\n  type OptionalPropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst preserveMissingMessageAnnotation = AST.whiteListAnnotations([AST.MissingMessageAnnotationId])\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = util_.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.AutoTitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.AutoTitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = util_.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nconst makeTypeLiteralClass = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> => {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @see {@link TaggedStruct}\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @since 3.10.0\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): Record$<K, V>\n}\n\nconst makeRecordClass = <K extends Schema.All, V extends Schema.All>(\n  key: K,\n  value: V,\n  ast?: AST.AST\n): Record$<K, V> => (class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n  static override annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ) {\n    return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static key = key\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(\n  options: { readonly key: K; readonly value: V }\n): Record$<K, V> => makeRecordClass(options.key, options.value)\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = Schema.Struct({\n *   column1: Schema.NumberFromString,\n *   column2: Schema.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n *\n * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n * ```\n *\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pluck: {\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, K extends keyof A & keyof I>(\n    key: K\n  ): <R>(schema: Schema<A, I, R>) => Schema<A[K], { readonly [P in K]: I[P] }, R>\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], { readonly [P in K]: I[P] }, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make<\n      /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      R\n    >(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    return transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (a: any) => a[key],\n        encode: (ak) => ps.isOptional && ak === undefined ? {} : { [key]: ak } as any\n      }\n    )\n  }\n)\n\n/**\n * @category branding\n * @since 3.10.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nconst makeBrandClass = <S extends Schema.Any, B extends string | symbol>(\n  ast: AST.AST\n): brand<S, B> => (class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n  static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n    return makeBrandClass(mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n * ```\n *\n * @category branding\n * @since 3.10.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      // add a default title annotation containing the brand\n      title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,\n      ...annotations,\n      [AST.BrandAnnotationId]: annotation\n    })\n  )\n  return makeBrandClass(ast)\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partial = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>\n  make(AST.partial(self.ast))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partialWith: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(\n    self: Schema<A, I, R>,\n    options: Options\n  ): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.blackListAnnotations([\n  AST.IdentifierAnnotationId\n])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.AST => AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (y._tag) {\n        case \"Literal\": {\n          if (\n            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||\n              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||\n              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))\n          ) {\n            return [y]\n          }\n          break\n        }\n        case \"StringKeyword\": {\n          if (y === AST.stringKeyword) {\n            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.stringKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"NumberKeyword\": {\n          if (y === AST.numberKeyword) {\n            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.numberKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"BooleanKeyword\": {\n          if (y === AST.booleanKeyword) {\n            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.booleanKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"Union\":\n          return intersectUnionMembers(getTypes(x), y.types, path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n        case \"Refinement\":\n          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))\n        case \"TypeLiteral\": {\n          switch (x._tag) {\n            case \"Union\":\n              return intersectUnionMembers(x.types, [y], path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n            case \"Refinement\":\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              if (AST.isTypeLiteralTransformation(x.transformation)) {\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x.from, y, path),\n                    intersectTypeLiterals(x.to, AST.typeAST(y), path),\n                    new AST.TypeLiteralTransformation(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              }\n              break\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTypeLiteralTransformation(y.transformation)) {\n            switch (x._tag) {\n              case \"Union\":\n                return intersectUnionMembers(x.types, [y], path)\n              case \"Suspend\":\n                return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n              case \"Refinement\":\n                return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n              case \"TypeLiteral\":\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x, y.from, path),\n                    intersectTypeLiterals(AST.typeAST(x), y.to, path),\n                    new AST.TypeLiteralTransformation(\n                      y.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              case \"Transformation\":\n                {\n                  if (AST.isTypeLiteralTransformation(x.transformation)) {\n                    return [\n                      new AST.Transformation(\n                        intersectTypeLiterals(x.from, y.from, path),\n                        intersectTypeLiterals(x.to, y.to, path),\n                        new AST.TypeLiteralTransformation(\n                          y.transformation.propertySignatureTransformations.concat(\n                            x.transformation.propertySignatureTransformations\n                          )\n                        )\n                      )\n                    ]\n                  }\n                }\n                break\n            }\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema with another schema.\n *\n * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n *\n * Possible extensions include:\n * - `Schema.String` with another `Schema.String` refinement or a string literal\n * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n * - A struct with another struct where overlapping fields support extension\n * - A struct with in index signature\n * - A struct with a union of supported schemas\n * - A refinement of a struct with a supported schema\n * - A suspend of a struct with a supported schema\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: Schema<\n * //   {\n * //     readonly a: string\n * //     readonly b: string\n * //   } & {\n * //     readonly c: string\n * //   } & {\n * //     readonly [x: string]: string\n * //   }\n * // >\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n * ))\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const extend: {\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const compose: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C extends B, R2, B>(to: Schema<D, C, R2>): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(to: Schema<D, C, R2>): <B extends C, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <C, B, R2>(\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): <B, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C extends B, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B extends C, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): SchemaClass<D, A, R1 | R2>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    make(AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const RefineSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Refine\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type RefineSchemaId = typeof RefineSchemaId\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  readonly [RefineSchemaId]: From // required for `type HasFields = ...`\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nconst makeRefineClass = <From extends Schema.Any, A>(\n  from: From,\n  filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> => (class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n  static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n    return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static [RefineSchemaId] = from\n\n  static from = from\n\n  static filter = filter\n\n  static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 3.10.0\n */\nexport const filterEffect: {\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (a, options, ast) =>\n        ParseResult.flatMap(\n          f(a, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, a), {\n              onNone: () => ParseResult.succeed(a),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: ParseResult.succeed\n    }\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nconst makeTransformationClass = <From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<\n  From,\n  To,\n  R\n> => (class TransformationClass\n  extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n    return makeTransformationClass<From, To, R>(\n      this.from,\n      this.to,\n      mergeSchemaAnnotations(this.ast, annotations)\n    )\n  }\n\n  static from = from\n\n  static to = to\n})\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transformOrFail: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      fromI: FromI\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      toA: ToA\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transform: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA, fromI: FromI) => ToI\n      readonly encode: (toI: ToI, toA: ToA) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),\n        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const transformLiteral = <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> =>\n  transform(Literal(from), Literal(to), { strict: true, decode: () => to, encode: () => from })\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const attachPropertySignature: {\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * ```ts\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: SchemaClass<A, I, R>\n  ) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * ```ts\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 3.10.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * Merges a set of new annotations with existing ones, potentially overwriting\n * any duplicates.\n *\n * @category annotations\n * @since 3.10.0\n */\nexport const annotations: {\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.Schema<A>): Schema<A, I, R> => self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 3.10.0\n */\nexport const rename: {\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const TrimmedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const trimmed =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.trim(), {\n        schemaId: TrimmedSchemaId,\n        description: \"a string with no leading or trailing whitespace\",\n        jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxLengthSchemaId: unique symbol = filters_.MaxLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxLengthSchemaId = typeof MaxLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const maxLength = <A extends string>(\n  maxLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length <= maxLength,\n      {\n        schemaId: MaxLengthSchemaId,\n        description: `a string at most ${maxLength} character(s) long`,\n        jsonSchema: { maxLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinLengthSchemaId: unique symbol = filters_.MinLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinLengthSchemaId = typeof MinLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const minLength = <A extends string>(\n  minLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        schemaId: MinLengthSchemaId,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PatternSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Pattern\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const pattern = <A extends string>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const pattern = regex.source\n  return self.pipe(\n    filter(\n      (a): a is A => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        schemaId: PatternSchemaId,\n        [PatternSchemaId]: { regex },\n        description: `a string matching the pattern ${pattern}`,\n        jsonSchema: { pattern },\n        arbitrary: () => (fc) => fc.stringMatching(regex) as any,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const StartsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/StartsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const startsWith = <A extends string>(\n  startsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        schemaId: StartsWithSchemaId,\n        [StartsWithSchemaId]: { startsWith },\n        description: `a string starting with ${JSON.stringify(startsWith)}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const EndsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/EndsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const endsWith = <A extends string>(\n  endsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        schemaId: EndsWithSchemaId,\n        [EndsWithSchemaId]: { endsWith },\n        description: `a string ending with ${JSON.stringify(endsWith)}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IncludesSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Includes\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const includes = <A extends string>(\n  searchString: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        schemaId: IncludesSchemaId,\n        [IncludesSchemaId]: { includes: searchString },\n        description: `a string including ${JSON.stringify(searchString)}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LowercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const lowercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        schemaId: LowercasedSchemaId,\n        description: \"a lowercase string\",\n        jsonSchema: { pattern: \"^[^A-Z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\", title: \"Lowercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const CapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const capitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        schemaId: CapitalizedSchemaId,\n        description: \"a capitalized string\",\n        jsonSchema: { pattern: \"^[^a-z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\", title: \"Capitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UncapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uncapitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        schemaId: UncapitalizedSchemaId,\n        description: \"a uncapitalized string\",\n        jsonSchema: { pattern: \"^[^A-Z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\", title: \"Uncapitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UppercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uppercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        schemaId: UppercasedSchemaId,\n        description: \"an uppercase string\",\n        jsonSchema: { pattern: \"^[^a-z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\", title: \"Uppercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LengthSchemaId: unique symbol = filters_.LengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LengthSchemaId = typeof LengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const length = <A extends string>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        schemaId: LengthSchemaId,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      schemaId: LengthSchemaId,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const nonEmptyString = <A extends string>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  minLength(1, {\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Lowercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to lowercase\" }),\n  Lowercased,\n  { strict: true, decode: (s) => s.toLowerCase(), encode: identity }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uppercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to uppercase\" }),\n  Uppercased,\n  { strict: true, decode: (s) => s.toUpperCase(), encode: identity }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Capitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to a capitalized format\" }),\n  Capitalized,\n  { strict: true, decode: (s) => string_.capitalize(s), encode: identity }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uncapitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to an uncapitalized format\" }),\n  Uncapitalized,\n  { strict: true, decode: (s) => string_.uncapitalize(s), encode: identity }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\", title: \"Trimmed\" })\n) {}\n\n/**\n * Useful for validating strings that must contain meaningful characters without\n * leading or trailing whitespace.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyTrimmedString extends Trimmed.pipe(\n  nonEmptyString({ identifier: \"NonEmptyTrimmedString\", title: \"NonEmptyTrimmedString\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Trim extends transform(\n  String$.annotations({ description: \"a string that will be trimmed\" }),\n  Trimmed,\n  { strict: true, decode: (s) => s.trim(), encode: identity }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const split = (separator: string): transform<typeof String$, Array$<typeof String$>> =>\n  transform(\n    String$.annotations({ description: \"a string that will be split\" }),\n    Array$(String$),\n    { strict: true, decode: string_.split(separator), encode: array_.join(separator) }\n  )\n\n/**\n * @since 3.10.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst JsonString = String$.annotations({\n  [AST.IdentifierAnnotationId]: \"JsonString\",\n  [AST.TitleAnnotationId]: \"JsonString\",\n  [AST.DescriptionAnnotationId]: \"a string that will be parsed as JSON\"\n})\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions) =>\n  transformOrFail(\n    JsonString,\n    Unknown,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(s, options?.reviver),\n          catch: (e: any) => new ParseResult.Type(ast, s, e.message)\n        }),\n      encode: (u, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(u, options?.replacer, options?.space),\n          catch: (e: any) => new ParseResult.Type(ast, u, e.message)\n        })\n    }\n  ).annotations({ schemaId: AST.ParseJsonSchemaId })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n * ```\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const parseJson: {\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schemaOrOptions)\n    ? compose(parseJson(o), schemaOrOptions) as any\n    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyString extends String$.pipe(\n  nonEmptyString({ identifier: \"NonEmptyString\", title: \"NonEmptyString\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UUIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    schemaId: UUIDSchemaId,\n    identifier: \"UUID\",\n    title: \"UUID\",\n    jsonSchema: {\n      format: \"uuid\",\n      pattern: uuidRegexp.source\n    },\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ULIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    schemaId: ULIDSchemaId,\n    identifier: \"ULID\",\n    title: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * Defines a schema that represents a `URL` object.\n *\n * @category URL constructors\n * @since 3.11.0\n */\nexport class URLFromSelf extends instanceOf(URL, {\n  identifier: \"URLFromSelf\",\n  title: \"URLFromSelf\",\n  arbitrary: (): LazyArbitrary<URL> => (fc) => fc.webUrl().map((s) => new URL(s)),\n  pretty: () => (url) => url.toString()\n}) {}\n\n/** @ignore */\nclass URL$ extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a URL\" }),\n  URLFromSelf,\n  {\n    strict: true,\n    decode: (str, _, ast) =>\n      ParseResult.try({\n        try: () => new URL(str),\n        catch: () => new ParseResult.Type(ast, str)\n      }),\n    encode: (url) => ParseResult.succeed(url.toString())\n  }\n).annotations({\n  identifier: \"URL\",\n  title: \"URL\",\n  pretty: () => (url) => url.toString()\n}) {}\n\nexport {\n  /**\n   * Defines a schema that attempts to convert a `string` to a `URL` object using\n   * the `new URL` constructor.\n   *\n   * @category URL transformations\n   * @since 3.11.0\n   */\n  URL$ as URL\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const FiniteSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Finite\")\n\n/**\n * Ensures that the provided value is a finite number.\n *\n * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const finite =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isFinite(a), {\n        schemaId: FiniteSchemaId,\n        description: \"a finite number\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanSchemaId: unique symbol = filters_.GreaterThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanSchemaId = typeof GreaterThanSchemaId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThan = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanSchemaId,\n      description: min === 0 ? \"a positive number\" : `a number greater than ${min}`,\n      jsonSchema: { exclusiveMinimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToSchemaId: unique symbol = filters_.GreaterThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualTo = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToSchemaId,\n      description: min === 0 ? \"a non-negative number\" : `a number greater than or equal to ${min}`,\n      jsonSchema: { minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MultipleOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const multipleOf = <A extends number>(\n  divisor: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      schemaId: MultipleOfSchemaId,\n      description: `a number divisible by ${divisor}`,\n      jsonSchema: { multipleOf: Math.abs(divisor) }, // spec requires positive divisor\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IntSchemaId: unique symbol = filters_.IntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type IntSchemaId = typeof IntSchemaId\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const int =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        schemaId: IntSchemaId,\n        title: \"integer\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanSchemaId: unique symbol = filters_.LessThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanSchemaId = typeof LessThanSchemaId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThan =\n  <A extends number>(max: number, annotations?: Annotations.Filter<A>) =>\n  <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a < max, {\n        schemaId: LessThanSchemaId,\n        description: max === 0 ? \"a negative number\" : `a number less than ${max}`,\n        jsonSchema: { exclusiveMaximum: max },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToSchemaId: unique symbol = filters_.LessThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualTo = <A extends number>(\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToSchemaId,\n      description: max === 0 ? \"a non-positive number\" : `a number less than or equal to ${max}`,\n      jsonSchema: { maximum: max },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenSchemaId: unique symbol = filters_.BetweenSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenSchemaId = typeof BetweenSchemaId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const between = <A extends number>(\n  min: number,\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenSchemaId,\n      description: `a number between ${min} and ${max}`,\n      jsonSchema: { maximum: max, minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNaNSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/NonNaN\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNaN =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        schemaId: NonNaNSchemaId,\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const positive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThan(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const negative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThan(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonPositive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualTo(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNegative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualTo(0, annotations)\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const clamp =\n  (minimum: number, maximum: number) =>\n  <A extends number, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, between(minimum, maximum)),\n      { strict: false, decode: (self) => number_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const parseNumber = <A extends string, I, R>(\n  self: Schema<A, I, R>\n): transformOrFail<Schema<A, I, R>, typeof Number$> =>\n  transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),\n      encode: (n) => ParseResult.succeed(String(n))\n    }\n  )\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport class NumberFromString extends parseNumber(String$.annotations({\n  description: \"a string that will be parsed into a number\"\n})).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\", title: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\", title: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\", title: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\", title: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\", title: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\", title: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\", title: \"NonNegative\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const JsonNumberSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/JsonNumber\")\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const is = Schema.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n * ```\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class JsonNumber extends Number$.pipe(\n  filter(Number.isFinite, {\n    schemaId: JsonNumberSchemaId,\n    identifier: \"JsonNumber\",\n    title: \"JSON-compatible number\",\n    description: \"a JSON-compatible number, excluding NaN, +Infinity, and -Infinity\",\n    jsonSchema: { type: \"number\" }\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 3.10.0\n */\nexport class Not extends transform(Boolean$.annotations({ description: \"a boolean that will be negated\" }), Boolean$, {\n  strict: true,\n  decode: boolean_.not,\n  encode: boolean_.not\n}) {}\n\n/** @ignore */\nclass Symbol$ extends transform(\n  String$.annotations({ description: \"a string that will be converted to a symbol\" }),\n  SymbolFromSelf,\n  { strict: false, decode: (s) => Symbol.for(s), encode: (sym) => sym.description }\n).annotations({ identifier: \"symbol\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `symbol`.\n   *\n   * @category symbol transformations\n   * @since 3.10.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigIntSchemaId: unique symbol = filters_.GreaterThanBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanBigIntSchemaId,\n      [GreaterThanBigIntSchemaId]: { min },\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigIntSchemaId: unique symbol = filters_.GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToBigIntSchemaId,\n      [GreaterThanOrEqualToBigIntSchemaId]: { min },\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigIntSchemaId: unique symbol = filters_.LessThanBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanBigIntSchemaId,\n      [LessThanBigIntSchemaId]: { max },\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigIntSchemaId: unique symbol = filters_.LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToBigIntSchemaId,\n      [LessThanOrEqualToBigIntSchemaId]: { max },\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigIntSchemaId: unique symbol = filters_.BetweenBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const betweenBigInt = <A extends bigint>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenBigIntSchemaId,\n      [BetweenBigIntSchemaId]: { max, min },\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const positiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const negativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonNegativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualToBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonPositiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualToBigInt(0n, annotations)\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport const clampBigInt =\n  (minimum: bigint, maximum: bigint) =>\n  <A extends bigint, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n      { strict: false, decode: (self) => bigInt_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"bigint\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 3.10.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\", title: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\", title: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\", title: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\", title: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\", title: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\", title: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\", title: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\", title: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (n, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(n),\n        () => new ParseResult.Type(ast, n)\n      ),\n    encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))\n  }\n).annotations({ identifier: \"BigintFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map(redacted_.make)\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 3.10.0\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(\n  value: Value\n): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Redacted<Value extends Schema.Any> extends\n  AnnotableClass<\n    Redacted<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    Schema.Encoded<Value>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * A schema that transforms any type `A` into a `Redacted<A>`.\n *\n * @category Redacted transformations\n * @since 3.10.0\n */\nexport const Redacted = <Value extends Schema.Any>(\n  value: Value\n): Redacted<Value> => {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(value)),\n    {\n      strict: true,\n      decode: (value) => redacted_.make(value),\n      encode: (value) => redacted_.value(value)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 3.10.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigUint().map((_) => duration_.nanos(_)),\n        fc.bigUint().map((_) => duration_.micros(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_)),\n        fc.maxSafeNat().map((_) => duration_.seconds(_)),\n        fc.maxSafeNat().map((_) => duration_.minutes(_)),\n        fc.maxSafeNat().map((_) => duration_.hours(_)),\n        fc.maxSafeNat().map((_) => duration_.days(_)),\n        fc.maxSafeNat().map((_) => duration_.weeks(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a `bigint` tuple into a `Duration`.\n * Treats the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  BigIntFromSelf.annotations({ description: \"a bigint that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (nanos) => ParseResult.succeed(duration_.nanos(nanos)),\n    encode: (duration, _, ast) =>\n      option_.match(duration_.toNanos(duration), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),\n        onSome: (val) => ParseResult.succeed(val)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A schema that transforms a `number` tuple into a `Duration`.\n * Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromMillis extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  { strict: true, decode: (ms) => duration_.millis(ms), encode: (n) => duration_.toMillis(n) }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\nconst hrTime: Schema<readonly [seconds: number, nanos: number]> = Tuple(\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"seconds\",\n      [AST.DescriptionAnnotationId]: \"seconds\"\n    })\n  ),\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"nanos\",\n      [AST.DescriptionAnnotationId]: \"nanos\"\n    })\n  )\n)\n\n/**\n * A schema that transforms a `[number, number]` tuple into a `Duration`.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class Duration extends transform(\n  hrTime.annotations({ description: \"a tuple of seconds and nanos that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),\n    encode: (duration) => duration_.toHrTime(duration)\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <A extends duration_.Duration, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      { strict: false, decode: (self) => duration_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      schemaId: GreaterThanDurationSchemaId,\n      [GreaterThanDurationSchemaId]: { min },\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToDurationSchemaId,\n      [GreaterThanOrEqualToDurationSchemaId]: { min },\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const betweenDuration = <A extends duration_.Duration>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      schemaId: BetweenDurationSchemaId,\n      [BetweenDurationSchemaId]: { maximum, minimum },\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 3.10.0\n */\nexport const Uint8ArrayFromSelf: Schema<Uint8Array> = declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n)\n\nconst Uint8Array$: Schema<Uint8Array, ReadonlyArray<number>> = transform(\n  Array$(Number$.pipe(\n    between(0, 255, {\n      title: \"8-bit unsigned integer\",\n      description: \"a 8-bit unsigned integer\"\n    })\n  )).annotations({ description: \"an array of 8-bit unsigned integers that will be parsed into a Uint8Array\" }),\n  Uint8ArrayFromSelf,\n  { strict: true, decode: (numbers) => Uint8Array.from(numbers), encode: (uint8Array) => Array.from(uint8Array) }\n).annotations({ identifier: \"Uint8Array\" })\n\nexport {\n  /**\n   * A schema that transforms an array of numbers into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 3.10.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeUint8ArrayTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n) =>\n  transformOrFail(\n    String$.annotations({ description: \"a string that will be parsed into a Uint8Array\" }),\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromHex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,\n  encode: (u: string) => string\n) =>\n  transformOrFail(\n    String$.annotations({\n      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`\n    }),\n    String$,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: `StringFrom${id}` })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64: Schema<string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64String,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64Url: Schema<string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64UrlString,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromHex: Schema<string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHexString,\n  Encoding.encodeHex\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinItemsSchemaId: unique symbol = filters_.MinItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinItemsSchemaId = typeof MinItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const minItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        schemaId: MinItemsSchemaId,\n        description: `an array of at least ${minItems} item(s)`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxItemsSchemaId: unique symbol = filters_.MaxItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxItemsSchemaId = typeof MaxItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const maxItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length <= n, {\n      schemaId: MaxItemsSchemaId,\n      description: `an array of at most ${n} item(s)`,\n      jsonSchema: { maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ItemsCountSchemaId: unique symbol = filters_.ItemsCountSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type ItemsCountSchemaId = typeof ItemsCountSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const itemsCount = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length === n, {\n      schemaId: ItemsCountSchemaId,\n      description: `an array of exactly ${n} item(s)`,\n      jsonSchema: { minItems: n, maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const head = <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>): SchemaClass<option_.Option<A>, I, R> =>\n  transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    { strict: true, decode: array_.head, encode: option_.match({ onNone: () => [], onSome: array_.of }) }\n  )\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const headOrElse: {\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (as, _, ast) =>\n          as.length > 0\n            ? ParseResult.succeed(as[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, as)),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ValidDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 3.10.0\n */\nexport const validDate =\n  (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>): filter<Schema<Date, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        schemaId: ValidDateSchemaId,\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      description: `a date before ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      description: `a date before or equal to ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanDateSchemaId,\n      [GreaterThanDateSchemaId]: { min },\n      description: `a date after ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToDateSchemaId,\n      [GreaterThanOrEqualToDateSchemaId]: { min },\n      description: `a date after or equal to ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const betweenDate = <A extends Date>(\n  minimum: Date,\n  maximum: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= maximum && a >= minimum, {\n      schemaId: BetweenDateSchemaId,\n      [BetweenDateSchemaId]: { maximum, minimum },\n      description: `a date between ${util_.formatDate(minimum)} and ${util_.formatDate(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    description: \"a potentially invalid Date instance\",\n    pretty: (): pretty_.Pretty<Date> => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: (): LazyArbitrary<Date> => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromString extends transform(\n  String$.annotations({ description: \"a string that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (s) => new Date(s), encode: (d) => util_.formatDate(d) }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 3.10.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromNumber extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (n) => new Date(n), encode: (d) => d.getTime() }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * Describes a schema that represents a `DateTime.Utc` instance.\n *\n * @category DateTime.Utc constructors\n * @since 3.10.0\n */\nexport class DateTimeUtcFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),\n  {\n    identifier: \"DateTimeUtcFromSelf\",\n    description: \"a DateTime.Utc instance\",\n    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) => fc.date().map((date) => dateTime.unsafeFromDate(date)),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\nconst decodeDateTime = <A extends dateTime.DateTime.Input>(input: A, _: ParseOptions, ast: AST.AST) =>\n  ParseResult.try({\n    try: () => dateTime.unsafeMake(input),\n    catch: () => new ParseResult.Type(ast, input)\n  })\n\n/**\n * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtcFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.toEpochMillis(dt))\n  }\n).annotations({ identifier: \"DateTimeUtcFromNumber\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtc extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.formatIso(dt))\n  }\n).annotations({ identifier: \"DateTimeUtc\" }) {}\n\nconst timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>\n  fc.integer({ min: -12 * 60 * 60 * 1000, max: 12 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)\n\n/**\n * Describes a schema that represents a `TimeZone.Offset` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneOffsetFromSelf extends declare(\n  dateTime.isTimeZoneOffset,\n  {\n    identifier: \"TimeZoneOffsetFromSelf\",\n    description: \"a TimeZone.Offset instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),\n    arbitrary: timeZoneOffsetArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneOffset extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a TimeZone.Offset\" }),\n  TimeZoneOffsetFromSelf,\n  { strict: true, decode: dateTime.zoneMakeOffset, encode: (tz) => tz.offset }\n).annotations({ identifier: \"TimeZoneOffset\" }) {}\n\nconst timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>\n  fc.constantFrom(...Intl.supportedValuesOf(\"timeZone\")).map(dateTime.zoneUnsafeMakeNamed)\n\n/**\n * Describes a schema that represents a `TimeZone.Named` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneNamedFromSelf extends declare(\n  dateTime.isTimeZoneNamed,\n  {\n    identifier: \"TimeZoneNamedFromSelf\",\n    description: \"a TimeZone.Named instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),\n    arbitrary: timeZoneNamedArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneNamed extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone.Named\" }),\n  TimeZoneNamedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      ParseResult.try({\n        try: () => dateTime.zoneUnsafeMakeNamed(s),\n        catch: () => new ParseResult.Type(ast, s)\n      }),\n    encode: (tz) => ParseResult.succeed(tz.id)\n  }\n).annotations({ identifier: \"TimeZoneNamed\" }) {}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TimeZoneFromSelf extends Union<[typeof TimeZoneOffsetFromSelf, typeof TimeZoneNamedFromSelf]> {\n  annotations(annotations: Annotations.Schema<dateTime.TimeZone>): TimeZoneFromSelf\n}\n\n/**\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport const TimeZoneFromSelf: TimeZoneFromSelf = Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZone extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone\" }),\n  TimeZoneFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.zoneFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (tz) => ParseResult.succeed(dateTime.zoneToString(tz))\n  }\n).annotations({ identifier: \"TimeZone\" }) {}\n\nconst timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>\n  fc.oneof(\n    timeZoneOffsetArbitrary()(fc),\n    timeZoneNamedArbitrary()(fc)\n  )\n\n/**\n * Describes a schema that represents a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned constructors\n * @since 3.10.0\n */\nexport class DateTimeZonedFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),\n  {\n    identifier: \"DateTimeZonedFromSelf\",\n    description: \"a DateTime.Zoned instance\",\n    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>\n      fc.date().chain((date) => timeZoneArbitrary(fc).map((timeZone) => dateTime.unsafeMakeZoned(date, { timeZone }))),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned transformations\n * @since 3.10.0\n */\nexport class DateTimeZoned extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Zoned\" }),\n  DateTimeZonedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.makeZonedFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (dt) => ParseResult.succeed(dateTime.formatIsoZoned(dt))\n  }\n).annotations({ identifier: \"DateTimeZoned\" }) {}\n\n/**\n * @category Option utils\n * @since 3.10.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary =\n  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>\n    fc.oneof(\n      ctx,\n      fc.record({ _tag: fc.constant(\"None\" as const) }),\n      fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n    ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(\n  value: Value\n): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  AnnotableClass<\n    Option<Value>,\n    option_.Option<Schema.Type<Value>>,\n    OptionEncoded<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const Option = <Value extends Schema.Any>(value: Value): Option<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: optionDecode,\n      encode: option_.match({\n        onNone: () => makeNoneEncoded,\n        onSome: makeSomeEncoded\n      })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromNullOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrNull\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullishOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullishOr = <Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NullishOr(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: option_.fromNullable,\n      encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromUndefinedOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromUndefinedOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromUndefinedOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrUndefined\n  })\n}\n\n/**\n * Transforms strings into an Option type, effectively filtering out empty or\n * whitespace-only strings by trimming them and checking their length. Returns\n * `none` for invalid inputs and `some` for valid non-empty strings.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNonEmptyTrimmedString = transform(String$, OptionFromSelf(NonEmptyTrimmedString), {\n  strict: true,\n  decode: (s) => {\n    const out = s.trim()\n    return out.length === 0 ? option_.none() : option_.some(out)\n  },\n  encode: option_.getOrElse(() => \"\")\n})\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <RA, RI, RR>(right: Schema<RA, RI, RR>): Schema<RightEncoded<RA>, RightEncoded<RI>, RR> =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <LA, LI, LR>(left: Schema<LA, LI, LR>): Schema<LeftEncoded<LA>, LeftEncoded<LI>, LR> =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <RA, RI, RR, LA, LI, LR>(\n  right: Schema<RA, RI, RR>,\n  left: Schema<LA, LI, LR>\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Either<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    Either<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  return transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: eitherDecode,\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromUnion<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromUnion<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    Schema.Encoded<R> | Schema.Encoded<L>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n * ```\n *\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromUnion = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromUnion<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: makeRightEncoded,\n    encode: (r) => r.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: makeLeftEncoded,\n    encode: (l) => l.left\n  })\n  return transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (from) => from._tag === \"Left\" ? either_.left(from.left) : either_.right(from.right),\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<Map<K, V>> => {\n  return (fc) => {\n    const items = fc.array(fc.tuple(key(fc), value(fc)))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))\n  }\n}\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 3.10.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category Map\n * @since 3.10.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMap$<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    ReadonlyMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    Map$<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst map = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    MapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 3.10.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a ReadonlyMap\"\n    }),\n    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\n/**\n * @category Map transformations\n * @since 3.10.0\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a Map\"\n    }),\n    MapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\nconst setArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))\n  }\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 3.10.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Set\n * @since 3.10.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySet$<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 3.10.0\n */\nexport const ReadonlySet = <Value extends Schema.Any>(value: Value): ReadonlySet$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ReadonlySetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Set$<Value extends Schema.Any> extends\n  AnnotableClass<\n    Set$<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst set = <Value extends Schema.Any>(value: Value): Set$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    SetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 3.10.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer({ min: 0, max: 18 }))\n    .map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num, _, ast) =>\n      bigDecimal_.fromString(num).pipe(option_.match({\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (val) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimalFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num) => ParseResult.succeed(bigDecimal_.fromNumber(num)),\n    encode: (val) => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThan(a, min), {\n      schemaId: GreaterThanBigDecimalSchemaId,\n      [GreaterThanBigDecimalSchemaId]: { min },\n      description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToBigDecimalSchemaId,\n      [GreaterThanOrEqualToBigDecimalSchemaId]: { min },\n      description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThan(a, max), {\n      schemaId: LessThanBigDecimalSchemaId,\n      [LessThanBigDecimalSchemaId]: { max },\n      description: `a BigDecimal less than ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanOrEqualToBigDecimalSchemaId,\n      [LessThanOrEqualToBigDecimalSchemaId]: { max },\n      description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const positiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isPositive(a), {\n      schemaId: PositiveBigDecimalSchemaId,\n      description: `a positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({\n    identifier: \"PositiveBigDecimalFromSelf\",\n    title: \"PositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonNegativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value >= 0n, {\n      schemaId: NonNegativeBigDecimalSchemaId,\n      description: `a non-negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({\n    identifier: \"NonNegativeBigDecimalFromSelf\",\n    title: \"NonNegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const negativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isNegative(a), {\n      schemaId: NegativeBigDecimalSchemaId,\n      description: `a negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({\n    identifier: \"NegativeBigDecimalFromSelf\",\n    title: \"NegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonPositiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value <= 0n, {\n      schemaId: NonPositiveBigDecimalSchemaId,\n      description: `a non-positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({\n    identifier: \"NonPositiveBigDecimalFromSelf\",\n    title: \"NonPositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const betweenBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      schemaId: BetweenBigDecimalSchemaId,\n      [BetweenBigDecimalSchemaId]: { maximum, minimum },\n      description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      { strict: false, decode: (self) => bigDecimal_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\nconst chunkArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)\n  }\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Chunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    Chunk<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const Chunk = <Value extends Schema.Any>(value: Value): Chunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ChunkFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (as) => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),\n      encode: chunk_.toReadonlyArray\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunk<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const NonEmptyChunk = <Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NonEmptyArray(value_),\n    NonEmptyChunkFromSelf(typeSchema(value_)),\n    { strict: true, decode: chunk_.unsafeFromNonEmptyArray, encode: chunk_.toReadonlyArray }\n  )\n}\n\nconst toData = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(toData)\n\nconst dataPretty = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), toData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const DataFromSelf = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  declare(\n    [item],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(item)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const Data = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  transform(\n    item,\n    DataFromSelf(typeSchema(item)),\n    { strict: false, decode: toData, encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a) }\n  )\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <newFields extends Struct.Fields>(\n    fields: newFields | HasFields<newFields>,\n    annotations?: Annotations.Schema<Extended>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & newFields,\n      I & Struct.Encoded<newFields>,\n      R | Struct.Context<newFields>,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [RefineSchemaId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n *  someField: Schema.String\n * }) {\n *  someMethod() {\n *    return this.someField + \"bar\"\n *  }\n * }\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n *  a: Schema.String\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n *   \"MyError\",\n *   {\n *     module: Schema.String,\n *     method: Schema.String,\n *     description: Schema.String\n *   }\n * ) {\n *   get message(): string {\n *     return `${this.module}.${this.method}: ${this.description}`\n *   }\n * }\n * ```\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: tag<Tag> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n    get message(): string {\n      return `{ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } }`\n    }\n  } as any\n}\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of util_.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\ntype MakeOptions = boolean | {\n  readonly disableValidation?: boolean\n}\n\nconst getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n  Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n\nconst astCache = globalValue(\"effect/Schema/astCache\", () => new WeakMap<any, AST.AST>())\n\nconst makeClass = ({ Base, annotations, disableToString, fields, identifier, kind, schema }: {\n  kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n  identifier: string\n  schema: Schema.Any\n  fields: Struct.Fields\n  Base: new(...args: ReadonlyArray<any>) => any\n  annotations?: Annotations.Schema<any> | undefined\n  disableToString?: boolean | undefined\n}): any => {\n  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)\n\n  const ts = typeSchema(schema)\n  const declarationSurrogate = ts.annotations({ identifier, ...annotations })\n  const typeSide = ts.annotations({ [AST.AutoTitleAnnotationId]: `${identifier} (Type side)` })\n  const transformationSurrogate = schema.annotations({ ...annotations })\n  const validateSchema = schema.annotations({ [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)` })\n  const encodedSide = schema.annotations({ [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)` })\n\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(validateSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast(): AST.AST {\n      if (astCache.has(this)) {\n        return astCache.get(this)!\n      }\n\n      const declaration: Schema.Any = declare(\n        [typeSide],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          // @ts-expect-error\n          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: declarationSurrogate.ast,\n          ...annotations\n        }\n      )\n\n      const transformation = transform(\n        encodedSide,\n        declaration,\n        { strict: true, decode: (input) => new this(input, true), encode: identity }\n      ).annotations({\n        [AST.JSONIdentifierAnnotationId]: identifier,\n        [AST.SurrogateAnnotationId]: transformationSurrogate.ast\n      })\n      astCache.set(this, transformation.ast)\n      return transformation.ast\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended>(identifier: string) {\n      return (newFieldsOr: Struct.Fields | HasFields<Struct.Fields>, annotations?: Annotations.Schema<Extended>) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n            .join(\", \")\n        } })`\n      },\n      configurable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 3.10.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int.annotations({\n    title: \"id\",\n    description: \"id\"\n  }),\n  startTimeMillis: Int.annotations({\n    title: \"startTimeMillis\",\n    description: \"startTimeMillis\"\n  })\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 3.10.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 3.10.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  { strict: true, decode: fiberIdDecode, encode: fiberIdEncode }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 3.10.0\n */\nexport type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n\nconst causeDieEncoded = <D, DI, R>(defect: Schema<D, DI, R>) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E, EI, R>(error: Schema<E, EI, R>) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nconst causeParallelEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Parallel\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeSequentialEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Sequential\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeEncoded = <E, EI, D, DI, R1, R2>(\n  error: Schema<E, EI, R1>,\n  defect: Schema<D, DI, R2>\n): Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> => {\n  const recur = suspend(() => out)\n  const out: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error),\n    causeDieEncoded(defect),\n    CauseInterruptEncoded,\n    causeSequentialEncoded(recur),\n    causeParallelEncoded(recur)\n  ).annotations({ title: `CauseEncoded<${format(error)}>` })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, D, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): CauseFromSelf<E, D> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      title: `Cause<${error.ast}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Cause<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Cause<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): Cause<E, D> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  return transform(\n    causeEncoded(error_, defect_),\n    CauseFromSelf({ error: typeSchema(error_), defect: Unknown }),\n    { strict: false, decode: causeDecode, encode: causeEncode }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Defect extends transform<typeof Unknown, typeof Unknown> {}\n\n/**\n * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\n * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\n * or converts other values to their string representations.\n *\n * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\n * or other values into their string forms.\n *\n * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.\n *\n * @category defect\n * @since 3.10.0\n */\nexport const Defect: Defect = transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (u) => {\n      if (Predicate.isObject(u) && \"message\" in u && typeof u.message === \"string\") {\n        const err = new Error(u.message, { cause: u })\n        if (\"name\" in u && typeof u.name === \"string\") {\n          err.name = u.name\n        }\n        err.stack = \"stack\" in u && typeof u.stack === \"string\" ? u.stack : \"\"\n        return err\n      }\n      return String(u)\n    },\n    encode: (defect) => {\n      if (defect instanceof Error) {\n        return {\n          name: defect.name,\n          message: defect.message\n          // no stack because of security reasons\n        }\n      }\n      return String(defect)\n    }\n  }\n).annotations({ identifier: \"Defect\" })\n\n/**\n * @category Exit utils\n * @since 3.10.0\n */\nexport type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E, EI, ER, D, DI, DR>(\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  })\n\nconst exitSuccessEncoded = <A, I, R>(\n  value: Schema<A, I, R>\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  })\n\nconst exitEncoded = <A, I, R, E, EI, ER, D, DI, DR>(\n  value: Schema<A, I, R>,\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n): Schema<ExitEncoded<A, E, D>, ExitEncoded<I, EI, DI>, R | ER | DR> =>\n  Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`\n  })\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    ExitFromSelf<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): ExitFromSelf<A, E, D> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      title: `Exit<${success.ast}, ${failure.ast}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Exit<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): Exit<A, E, D> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  const defect_ = asSchema(defect)\n  return transform(\n    exitEncoded(success_, failure_, defect_),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: Unknown }),\n    {\n      strict: false,\n      decode: exitDecode,\n      encode: (exit) =>\n        exit._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: exit.cause } as const\n          : { _tag: \"Success\", value: exit.value } as const\n    }\n  )\n}\n\nconst hashSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(\n      hashSet_.fromIterable\n    )\n  }\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSet<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSet = <Value extends Schema.Any>(value: Value): HashSet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    HashSetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => hashSet_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => {\n  const items = fc.array(fc.tuple(key(fc), value(fc)))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashMap_.fromIterable)\n}\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMap<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    HashMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => hashMap_.fromIterable(as), encode: (map) => Array.from(map) }\n  )\n}\n\nconst listArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)\n  }\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface List<Value extends Schema.Any> extends\n  AnnotableClass<\n    List<Value>,\n    list_.List<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const List = <Value extends Schema.Any>(value: Value): List<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ListFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => list_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst sortedSetArbitrary = <A>(\n  item: LazyArbitrary<A>,\n  ord: Order.Order<A>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<sortedSet_.SortedSet<A>> =>\n(fc) => {\n  const items = fc.array(item(fc))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) =>\n    sortedSet_.fromIterable(as, ord)\n  )\n}\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSet<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSet = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> => {\n  const value_ = asSchema(value)\n  const to = typeSchema(value_)\n  return transform(\n    Array$(value_),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (as) => sortedSet_.fromIterable(as, ordA),\n      encode: (set) => Array.from(sortedSet_.values(set))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n * @category boolean constructors\n * @since 3.10.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  { strict: true, decode: Predicate.isTruthy, encode: identity }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * Converts an `string` value into its corresponding `boolean`\n * (\"true\" as `true` and \"false\" as `false`).\n *\n * @category boolean transformations\n * @since 3.11.0\n */\nexport class BooleanFromString extends transform(\n  Literal(\"true\", \"false\"),\n  Boolean$,\n  { strict: true, decode: (value) => value === \"true\", encode: (value) => value ? \"true\" : \"false\" }\n).annotations({ identifier: \"BooleanFromString\" }) {}\n\n/**\n * @category Config validations\n * @since 3.10.0\n */\nexport const Config = <A>(name: string, schema: Schema<A, string>): config_.Config<A> => {\n  const decodeEither_ = decodeEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((a) =>\n      decodeEither_(a).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], ParseResult.TreeFormatter.formatErrorSync(error)))\n      )\n    )\n  )\n}\n\n// ---------------------------------------------\n// Serializable\n// ---------------------------------------------\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolSerializable: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbol\"\n)\n\n/**\n * The `Serializable` trait allows objects to define their own schema for\n * serialization.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace Serializable {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Serializable<any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializable = <S extends Serializable.All>(\n  serializable: S\n): Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>> => serializable as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const serializableSchema = <A, I, R>(self: Serializable<A, I, R>): Schema<A, I, R> => self[symbolSerializable]\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serialize = <A, I, R>(self: Serializable<A, I, R>): Effect.Effect<I, ParseResult.ParseError, R> =>\n  encodeUnknown(self[symbolSerializable])(self)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserialize: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R> =>\n    decodeUnknown(self[symbolSerializable])(value)\n)\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolWithResult: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbolResult\"\n)\n\n/**\n * The `WithResult` trait is designed to encapsulate the outcome of an\n * operation, distinguishing between success and failure cases. Each case is\n * associated with a schema that defines the structure and types of the success\n * or failure data.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace WithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never\n  /**\n   * @since 3.10.0\n   */\n  export type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never\n  /**\n   * @since 3.10.0\n   */\n  export type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = WithResult<any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | WithResult<any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asWithResult = <WR extends WithResult.All>(\n  withExit: WR\n): WithResult<\n  WithResult.Success<WR>,\n  WithResult.SuccessEncoded<WR>,\n  WithResult.Failure<WR>,\n  WithResult.FailureEncoded<WR>,\n  WithResult.Context<WR>\n> => withExit as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const failureSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<FA, FI, R> =>\n  self[symbolWithResult].failure\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const successSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<SA, SI, R> =>\n  self[symbolWithResult].success\n\nconst exitSchemaCache = globalValue(\n  \"effect/Schema/Serializable/exitSchemaCache\",\n  () => new WeakMap<object, Schema<any, any, any>>()\n)\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const exitSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<\n  exit_.Exit<SA, FA>,\n  ExitEncoded<SI, FI, unknown>,\n  R\n> => {\n  const proto = Object.getPrototypeOf(self)\n  if (!(symbolWithResult in proto)) {\n    return Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n  }\n  let schema = exitSchemaCache.get(proto)\n  if (schema === undefined) {\n    schema = Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n    exitSchemaCache.set(proto, schema)\n  }\n  return schema\n}\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <FA>(value: FA): <SA, SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<FI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (\n    value: unknown\n  ): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<FA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA>(value: SA): <SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<SA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeExit: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: exit_.Exit<SA, FA>\n  ): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: exit_.Exit<SA, FA>\n): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R> => encode(exitSchema(self))(value))\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeExit: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: unknown\n): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R> => decodeUnknown(exitSchema(self))(value))\n\n// ---------------------------------------------\n// SerializableWithResult\n// ---------------------------------------------\n\n/**\n * The `SerializableWithResult` trait is specifically designed to model remote\n * procedures that require serialization of their input and output, managing\n * both successful and failed outcomes.\n *\n * This trait combines functionality from both the `Serializable` and `WithResult`\n * traits to handle data serialization and the bifurcation of operation results\n * into success or failure categories.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace SerializableWithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializableWithResult = <SWR extends SerializableWithResult.All>(\n  procedure: SWR\n): SerializableWithResult<\n  Serializable.Type<SWR>,\n  Serializable.Encoded<SWR>,\n  Serializable.Context<SWR>,\n  WithResult.Success<SWR>,\n  WithResult.SuccessEncoded<SWR>,\n  WithResult.Failure<SWR>,\n  WithResult.FailureEncoded<SWR>,\n  WithResult.Context<SWR>\n> => procedure as any\n\n/**\n * @since 3.10.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @since 3.10.0\n   */\n  export type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n *  failure: Schema.String,\n *  success: Schema.Number,\n *  payload: { id: Schema.String }\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(\n    tag: Tag,\n    options: {\n      failure: Failure\n      success: Success\n      payload: Payload\n    },\n    annotations?: Annotations.Schema<Self>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: tag<Tag> } & Payload,\n      Success,\n      Failure\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, options.payload)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      static success = options.success\n      static failure = options.failure\n      get [symbolSerializable]() {\n        return this.constructor\n      }\n      get [symbolWithResult]() {\n        return {\n          failure: options.failure,\n          success: options.success\n        }\n      }\n    } as any\n  }\n\n// -------------------------------------------------------------------------------------------------\n// Equivalence compiler\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.\n *\n * @category Equivalence\n * @since 3.10.0\n */\nexport const equivalence = <A, I, R>(schema: Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getEquivalenceAnnotation = AST.getAnnotation<AST.EquivalenceAnnotation<any, any>>(AST.EquivalenceAnnotationId)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getEquivalenceAnnotation(ast)\n  if (option_.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const base = AST.getParameterBase(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(base)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecordOrArray(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","dateTime","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fastCheck_","fiberId_","dual","identity","globalValue","hashMap_","hashSet_","errors_","filters_","util_","list_","number_","option_","ParseResult","pipeArguments","Predicate","record_","redacted_","Request","AST","sortedSet_","string_","struct_","TypeId","Symbol","for","make","ast","SchemaClass","variance","Type","Encoded","Context","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","_A","_","_I","_R","builtInAnnotations","schemaId","SchemaIdAnnotationId","message","MessageAnnotationId","missingMessage","MissingMessageAnnotationId","identifier","IdentifierAnnotationId","title","TitleAnnotationId","description","DescriptionAnnotationId","examples","ExamplesAnnotationId","default","DefaultAnnotationId","documentation","DocumentationAnnotationId","jsonSchema","JSONSchemaAnnotationId","arbitrary","ArbitraryAnnotationId","pretty","PrettyAnnotationId","equivalence","EquivalenceAnnotationId","concurrency","ConcurrencyAnnotationId","batching","BatchingAnnotationId","parseIssueTitle","ParseIssueTitleAnnotationId","parseOptions","ParseOptionsAnnotationId","decodingFallback","DecodingFallbackAnnotationId","toASTAnnotations","out","key","id","asSchema","schema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","overrideOptions","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknown","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validate","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","Object","keys","filter","map","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","spans","h","ts","isLiteral","i","length","item","next","push","TemplateLiteralSpan","isNonEmptyArray","literalValueCoercions","bigint","v","isString","BigInt","boolean","null","TemplateLiteralParser","params","encodedSchemas","typeSchemas","coercions","param","encoded","isNumberKeyword","Number","isNumber","isBigInt","isBoolean","isNull","from","re","getTemplateLiteralCapturingRegExp","TemplateLiteralParserClass","transformOrFail","Tuple","strict","s","match","exec","slice","coerce","succeed","fail","source","JSON","stringify","tuple","join","declareConstructor","typeParameters","Declaration","tp","declarePrimitive","input","declare","Array","isArray","BrandSchemaId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","a","either","isLeft","some","left","none","InstanceOfSchemaId","instanceOf","name","Undefined","undefinedKeyword","Void","voidKeyword","Null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","getDefaultUnionAST","members","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","element","ElementImpl","OptionalType","optionalElement","_Token","type","isOptional","getDefaultTupleTypeAST","elements","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","args","makeArrayClass","value","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","ArrayEnsure","value_","ArrayEnsureClass","transform","ensure","arr","NonEmptyArrayEnsure","NonEmptyArrayEnsureClass","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","_tag","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","undefined","PropertySignatureTransformation","to","mergeSignatureAnnotations","PropertySignatureTypeId","isPropertySignature","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","onNone","onSome","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","flatMap","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf","isNotNull","isNotUndefined","optional","optionalWith","preserveMissingMessageAnnotation","whiteListAnnotations","getDefaultTypeLiteralAST","fields","records","ownKeys","pss","transformations","field","toAnnotations","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","Transformation","TypeLiteral","AutoTitleAnnotationId","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","ak","BrandClass","brand","annotation","getBrandAnnotation","brands","formatUnknown","BrandAnnotationId","partial","partialWith","required","mutable","intersectTypeLiterals","x","y","path","isTypeLiteral","findIndex","extendAST","concat","Error","getSchemaExtendErrorMessage","preserveRefinementAnnotations","blackListAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","types","xs","ys","isStringKeyword","isBooleanKeyword","isRefinement","Suspend","f","isTypeLiteralTransformation","transformation","propertySignatureTransformations","extend","that","compose","suspend","RefineSchemaId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","issue","Pointer","toFilterParseIssue","isSingle","issues","filterMap","Composite","filterEffect","filterReturnType","makeTransformationClass","TransformationClass","FinalTransformation","fromA","_options","_ast","toA","toI","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedSchemaId","trimmed","trim","pattern","MaxLengthSchemaId","maxLength","MinLengthSchemaId","minLength","PatternSchemaId","regex","lastIndex","test","fc","stringMatching","StartsWithSchemaId","startsWith","EndsWithSchemaId","endsWith","IncludesSchemaId","includes","searchString","LowercasedSchemaId","lowercased","toLowerCase","Lowercased","CapitalizedSchemaId","capitalized","toUpperCase","Capitalized","UncapitalizedSchemaId","uncapitalized","Uncapitalized","UppercasedSchemaId","uppercased","Uppercased","LengthSchemaId","Math","max","floor","min","Char","nonEmptyString","Lowercase","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","NonEmptyTrimmedString","Trim","split","separator","JsonString","getParseJsonTransformation","try","parse","reviver","catch","e","replacer","space","ParseJsonSchemaId","parseJson","schemaOrOptions","NonEmptyString","UUIDSchemaId","uuidRegexp","UUID","uuid","ULIDSchemaId","ulidRegexp","ULID","ulid","URLFromSelf","URL","webUrl","url","URL$","str","FiniteSchemaId","finite","isFinite","GreaterThanSchemaId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToSchemaId","greaterThanOrEqualTo","minimum","MultipleOfSchemaId","multipleOf","divisor","remainder","abs","IntSchemaId","int","isSafeInteger","LessThanSchemaId","lessThan","exclusiveMaximum","LessThanOrEqualToSchemaId","lessThanOrEqualTo","maximum","BetweenSchemaId","between","NonNaNSchemaId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","n","NumberFromString","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberSchemaId","JsonNumber","Not","not","Symbol$","sym","GreaterThanBigIntSchemaId","GreaterThanBigintSchemaId","greaterThanBigInt","GreaterThanOrEqualToBigIntSchemaId","greaterThanOrEqualToBigInt","LessThanBigIntSchemaId","lessThanBigInt","LessThanOrEqualToBigIntSchemaId","lessThanOrEqualToBigInt","BetweenBigIntSchemaId","BetweenBigintSchemaId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","fromNumber","b","toNumber","redactedArbitrary","toComposite","eff","onSuccess","actual","mapBoth","onFailure","redactedParse","isRedacted","RedactedFromSelf","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigUint","nanos","micros","maxSafeNat","millis","seconds","minutes","hours","days","weeks","DurationFromNanos","duration","toNanos","val","DurationFromMillis","ms","toMillis","hrTime","Duration","toHrTime","clampDuration","betweenDuration","LessThanDurationSchemaId","lessThanDuration","LessThanOrEqualToDurationSchemaId","lessThanOrEqualToDuration","GreaterThanDurationSchemaId","greaterThanDuration","GreaterThanOrEqualToDurationSchemaId","greaterThanOrEqualToDuration","BetweenDurationSchemaId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8Array$","numbers","Uint8Array","makeUint8ArrayTransformation","decodeException","Uint8ArrayFromBase64","decodeBase64","encodeBase64","Uint8ArrayFromBase64Url","decodeBase64Url","encodeBase64Url","Uint8ArrayFromHex","decodeHex","encodeHex","makeEncodingTransformation","StringFromBase64","decodeBase64String","StringFromBase64Url","decodeBase64UrlString","StringFromHex","decodeHexString","MinItemsSchemaId","minItems","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsSchemaId","maxItems","ItemsCountSchemaId","itemsCount","getNumberIndexedAccess","of","headOrElse","fallback","ValidDateSchemaId","validDate","getTime","LessThanDateSchemaId","lessThanDate","formatDate","LessThanOrEqualToDateSchemaId","lessThanOrEqualToDate","GreaterThanDateSchemaId","greaterThanDate","GreaterThanOrEqualToDateSchemaId","greaterThanOrEqualToDate","BetweenDateSchemaId","betweenDate","DateFromSelf","isDate","date","noInvalidDate","Date","ValidDateFromSelf","DateFromString","d","Date$","DateFromNumber","DateTimeUtcFromSelf","isDateTime","isUtc","unsafeFromDate","decodeDateTime","unsafeMake","DateTimeUtcFromNumber","dt","toEpochMillis","DateTimeUtc","formatIso","timeZoneOffsetArbitrary","integer","zoneMakeOffset","TimeZoneOffsetFromSelf","isTimeZoneOffset","zone","TimeZoneOffset","tz","offset","timeZoneNamedArbitrary","constantFrom","Intl","supportedValuesOf","zoneUnsafeMakeNamed","TimeZoneNamedFromSelf","isTimeZoneNamed","TimeZoneNamed","TimeZoneFromSelf","TimeZone","zoneFromString","zoneToString","timeZoneArbitrary","DateTimeZonedFromSelf","isZoned","chain","timeZone","unsafeMakeZoned","DateTimeZoned","makeZonedFromString","formatIsoZoned","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","ctx","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","OptionFromNonEmptyTrimmedString","getOrElse","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","l","mapArbitrary","items","array","depthIdentifier","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","key_","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","normalize","bigDecimalArbitrary","bigInt","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","num","BigDecimalFromNumber","unsafeToNumber","GreaterThanBigDecimalSchemaId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalSchemaId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalSchemaId","lessThanBigDecimal","LessThanOrEqualToBigDecimalSchemaId","lessThanOrEqualToBigDecimal","PositiveBigDecimalSchemaId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalSchemaId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalSchemaId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalSchemaId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalSchemaId","betweenBigDecimal","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","isNonEmpty","NonEmptyChunkFromSelf","NonEmptyChunk","toData","struct","dataArbitrary","dataPretty","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","TaggedErrorClass","disableToString","getASTDuplicatePropertySignatureErrorMessage","disableValidation","astCache","WeakMap","classSymbol","declarationSurrogate","typeSide","transformationSurrogate","validateSchema","encodedSide","fallbackInstanceOf","klass","has","get","declaration","arb","SurrogateAnnotationId","JSONIdentifierAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","defineProperty","configurable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeParallelEncoded","causeEncoded","causeSequentialEncoded","recur","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","cause","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","error_","defect_","Defect","err","stack","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exit","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","BooleanFromString","Config","decodeEither_","string","mapOrFail","InvalidData","TreeFormatter","formatErrorSync","symbolSerializable","asSerializable","serializable","serializableSchema","serialize","deserialize","symbolWithResult","asWithResult","withExit","failureSchema","successSchema","exitSchemaCache","exitSchema","proto","getPrototypeOf","serializeFailure","deserializeFailure","serializeSuccess","deserializeSuccess","serializeExit","deserializeExit","asSerializableWithResult","procedure","TaggedRequest","payload","TaggedRequestClass","go","getEquivalenceAnnotation","getAnnotation","hook","isSome","getEquivalenceUnsupportedErrorMessage","memoizeThunk","annotatedAST","len","j","aStringKeys","aSymbolKeys","getOwnPropertySymbols","aHas","hasOwnProperty","call","bHas","bSymbolKeys","bStringKeys","base","getParameterBase","isSymbolKeyword","aKeys","searchTree","getSearchTree","candidates","isRecordOrArray","buckets","otherwise","tuples"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4013, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}